<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Battle Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .mode-selector {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .mode-btn {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .mode-btn.online {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .mode-btn.offline {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .mode-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .mode-btn.active {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .stats-bar {
            display: flex;
            justify-content: space-around;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
        }

        .sidebar {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
        }

        .center-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .pack-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .pack-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pack-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .pack-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .pack-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .pack-cost {
            color: #ffd700;
            font-size: 1.2em;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
        }

        .character-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .character-card:hover {
            transform: scale(1.05);
        }

        .character-card.selected {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.1);
        }

        .character-icon {
            font-size: 2.5em;
            margin-bottom: 5px;
        }

        .character-name {
            font-size: 0.85em;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .character-level {
            font-size: 0.75em;
            opacity: 0.8;
        }

        .rarity-common { border-color: #808080; }
        .rarity-uncommon { border-color: #00ff00; }
        .rarity-rare { border-color: #0080ff; }
        .rarity-epic { border-color: #a020f0; }
        .rarity-legendary { border-color: #ffa500; }
        .rarity-ancient { border-color: #ff0000; }
        .rarity-extreme { border-color: #ff1493; }
        .rarity-mythic { border-color: #00ffff; }
        .rarity-honorable { border-color: #ffd700; }
        .rarity-master-class { border-color: #ff69b4; }
        .rarity-insane { border-color: #8b00ff; }
        .rarity-victorious { border-color: #ffffff; box-shadow: 0 0 15px #fff; }

        .world-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .world-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .world-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .world-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .world-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .world-requirement {
            font-size: 0.85em;
            opacity: 0.8;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-close {
            float: right;
            font-size: 2em;
            cursor: pointer;
            line-height: 0.8;
        }

        .battle-arena {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
        }

        .fighter {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .fighter-icon {
            font-size: 5em;
            margin-bottom: 10px;
        }

        .health-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff0000, #00ff00);
            height: 100%;
            transition: width 0.5s;
        }

        .vs-text {
            font-size: 3em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .battle-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        .battle-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .battle-log {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .pack-opening {
            text-align: center;
        }

        .pack-animation {
            font-size: 8em;
            margin: 30px 0;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .revealed-character {
            padding: 30px;
            text-align: center;
            animation: reveal 0.5s;
        }

        @keyframes reveal {
            from { transform: scale(0) rotate(180deg); opacity: 0; }
            to { transform: scale(1) rotate(0); opacity: 1; }
        }

        .revealed-icon {
            font-size: 8em;
            margin-bottom: 20px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab.active {
            background: rgba(255, 255, 255, 0.3);
        }

        .filter-section {
            margin-bottom: 15px;
        }

        .filter-btn {
            padding: 5px 15px;
            margin: 5px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .filter-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 15px;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            height: 100%;
            transition: width 0.3s;
        }

        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .auth-container {
            background: rgba(0, 0, 0, 0.4);
            padding: 40px;
            border-radius: 20px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .auth-tab.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
        }

        .auth-form h2 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.5em;
        }

        .auth-input {
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1em;
            transition: all 0.3s;
        }

        .auth-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .auth-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.2);
        }

        .auth-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .auth-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .error-message {
            color: #ff6b6b;
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
            min-height: 20px;
        }

        .success-message {
            color: #51cf66;
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
        }

        .battle-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1500;
            overflow-y: auto;
        }

        .battle-screen.active {
            display: block;
        }

        .world-bg-starter-plains {
            background: linear-gradient(135deg, #a8e063 0%, #56ab2f 100%);
        }

        .world-bg-forest-kingdom {
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
        }

        .world-bg-desert-ruins {
            background: linear-gradient(135deg, #f46b45 0%, #eea849 100%);
        }

        .world-bg-ice-caverns {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .world-bg-volcano-peak {
            background: linear-gradient(135deg, #ff0000 0%, #ff6600 100%);
        }

        .world-bg-ocean-depths {
            background: linear-gradient(135deg, #2193b0 0%, #6dd5ed 100%);
        }

        .world-bg-sky-castle {
            background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
        }

        .world-bg-shadow-realm {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }

        .world-bg-crystal-dimension {
            background: linear-gradient(135deg, #c471f5 0%, #fa71cd 100%);
        }

        .world-bg-ultimate-arena {
            background: linear-gradient(135deg, #ffd700 0%, #ff6347 100%);
        }

        .battle-header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
        }

        .battle-world-name {
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            margin-bottom: 10px;
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            color: white;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }

        .battle-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .battle-fighters {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            align-items: start;
            margin: 30px 0;
        }

        .battle-fighter {
            background: rgba(0, 0, 0, 0.4);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        .battle-fighter-icon {
            font-size: 6em;
            margin-bottom: 15px;
            animation: float 3s ease-in-out infinite;
            transition: all 0.3s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes attackGlow {
            0%, 100% { 
                filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
                transform: translateY(0) scale(1);
            }
            50% { 
                filter: drop-shadow(0 0 30px rgba(255, 215, 0, 1));
                transform: translateY(-20px) scale(1.3);
            }
        }

        @keyframes damageShake {
            0%, 100% { transform: translateY(0) translateX(0); filter: brightness(1); }
            10%, 30%, 50%, 70%, 90% { transform: translateY(0) translateX(-8px); filter: brightness(1.5); }
            20%, 40%, 60%, 80% { transform: translateY(0) translateX(8px); filter: brightness(0.7); }
        }

        @keyframes criticalHit {
            0% { 
                transform: translateY(0) scale(1) rotate(0deg);
                filter: drop-shadow(0 0 0px rgba(255, 0, 0, 0));
            }
            25% { 
                transform: translateY(-30px) scale(1.5) rotate(-10deg);
                filter: drop-shadow(0 0 40px rgba(255, 0, 0, 1));
            }
            50% { 
                transform: translateY(-40px) scale(1.6) rotate(10deg);
                filter: drop-shadow(0 0 50px rgba(255, 215, 0, 1));
            }
            75% { 
                transform: translateY(-30px) scale(1.5) rotate(-10deg);
                filter: drop-shadow(0 0 40px rgba(255, 0, 0, 1));
            }
            100% { 
                transform: translateY(0) scale(1) rotate(0deg);
                filter: drop-shadow(0 0 0px rgba(255, 0, 0, 0));
            }
        }

        .attacking {
            animation: attackGlow 0.8s ease-in-out !important;
        }

        .critical-attacking {
            animation: criticalHit 1s ease-in-out !important;
        }

        .taking-damage {
            animation: damageShake 0.6s ease-in-out !important;
        }

        .battle-fighter-name {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .battle-fighter-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
            font-size: 0.9em;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 5px;
        }

        .powers-section {
            margin-top: 20px;
        }

        .powers-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .power-buttons {
            display: grid;
            gap: 10px;
        }

        .power-btn {
            padding: 15px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .power-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateX(5px);
        }

        .power-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .power-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .power-desc {
            font-size: 0.85em;
            opacity: 0.8;
        }

        .power-damage {
            color: #ff6b6b;
            font-weight: bold;
        }

        .power-cooldown {
            color: #ffd700;
            font-size: 0.8em;
            margin-top: 5px;
        }

        .battle-vs {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        }

        .turn-indicator {
            text-align: center;
            padding: 15px;
            background: rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .battle-action-log {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            max-height: 250px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .action-entry {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 4px solid #4facfe;
        }

        .action-entry.damage {
            border-left-color: #ff6b6b;
        }

        .action-entry.heal {
            border-left-color: #51cf66;
        }

        .action-entry.critical {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .health-display {
            margin: 15px 0;
        }

        .health-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .health-bar-large {
            background: rgba(255, 255, 255, 0.2);
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .health-fill-large {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .battle-result {
            text-align: center;
            padding: 40px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            margin: 20px 0;
        }

        .battle-results-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .result-icon {
            font-size: 8em;
            margin-bottom: 20px;
        }

        .result-title {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .result-rewards {
            font-size: 1.3em;
            margin: 20px 0;
            line-height: 1.8;
        }

        .continue-btn {
            padding: 15px 40px;
            font-size: 1.3em;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .continue-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }

        /* Home Page Styles */
        .page-content {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .home-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .home-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 30px;
            margin-top: 40px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        .home-nav-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            color: white;
        }

        .home-nav-btn:hover {
            transform: translateY(-10px);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
        }

        .home-nav-icon {
            font-size: 5em;
            margin-bottom: 20px;
        }

        .home-nav-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .home-nav-desc {
            font-size: 1.1em;
            opacity: 0.8;
        }

        .page-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .back-btn {
            padding: 12px 24px;
            font-size: 1.1em;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateX(-5px);
        }

        .page-header h2 {
            font-size: 2.5em;
            margin: 0;
        }

        .main-with-sidebar {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .sidebar-stats {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
        }

        .battle-mode-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .battle-mode-card:hover {
            transform: translateY(-10px);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
        }

        .battle-mode-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.5);
        }

        .battle-mode-card.locked:hover {
            transform: none;
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
        }

        .battle-mode-card h3 {
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .battle-mode-card p {
            font-size: 1.1em;
            opacity: 0.8;
        }

        .tournament-bracket {
            padding: 20px;
            overflow-x: auto;
        }

        .bracket-round {
            display: inline-block;
            vertical-align: top;
            margin: 0 20px;
        }

        .bracket-round-title {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }

        .bracket-match {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            min-width: 180px;
        }

        .bracket-fighter {
            padding: 8px;
            margin: 3px 0;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }

        .bracket-fighter.winner {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4caf50;
        }

        .bracket-fighter.loser {
            opacity: 0.4;
        }

        .bracket-fighter.current {
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Shop Styles */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            padding: 20px;
        }

        .shop-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s;
        }

        .shop-item:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .shop-item.owned {
            border-color: rgba(76, 175, 80, 0.8);
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
        }

        .shop-item-icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .shop-item-name {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .shop-item-desc {
            font-size: 1em;
            opacity: 0.9;
            margin: 15px 0;
            line-height: 1.5;
        }

        .shop-item-price {
            font-size: 1.5em;
            color: #ffd700;
            margin: 15px 0;
            font-weight: bold;
        }

        .shop-buy-btn {
            padding: 12px 30px;
            font-size: 1.1em;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            border: none;
            border-radius: 10px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .shop-buy-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }

        .shop-buy-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }

        .trait-inventory {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .trait-badge {
            display: inline-block;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 140, 0, 0.3));
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 20px;
            padding: 8px 16px;
            margin: 5px;
            font-size: 1em;
        }

        /* Hide any error console boxes */
        #console,
        .console,
        .error-console,
        [id*="error-overlay"],
        [class*="error-overlay"],
        [id*="console"],
        [class*="console-container"] {
            display: none !important;
        }

        .mode-selection-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 1800;
            padding: 20px;
            overflow-y: auto;
        }

        .mode-selection-screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .mode-selection-container {
            background: rgba(0, 0, 0, 0.4);
            padding: 40px;
            border-radius: 20px;
            max-width: 800px;
            width: 100%;
        }

        .mode-selection-title {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .mode-selection-subtitle {
            text-align: center;
            font-size: 1.2em;
            opacity: 0.8;
            margin-bottom: 40px;
        }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .mode-option {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-option:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .mode-option.selected {
            border-color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.2));
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .mode-icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .mode-name {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .mode-description {
            font-size: 1em;
            opacity: 0.9;
            line-height: 1.4;
        }

        .mode-confirm-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.3em;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .mode-confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pack-preview-modal {
            background: rgba(0, 0, 0, 0.95);
        }

        .pack-preview-content {
            max-width: 700px;
            width: 90%;
        }

        .pack-preview-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .pack-preview-icon {
            font-size: 5em;
            margin-bottom: 15px;
        }

        .pack-preview-title {
            font-size: 2em;
            font-weight: bold;
        }

        .characters-preview {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .character-preview-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid;
        }

        .character-preview-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .character-preview-icon {
            font-size: 2em;
        }

        .character-preview-info {
            text-align: left;
        }

        .character-preview-name {
            font-weight: bold;
            font-size: 1.1em;
        }

        .character-preview-rarity {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .character-preview-chance {
            font-size: 1.2em;
            font-weight: bold;
            padding: 5px 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
        }

        .pack-preview-buttons {
            display: flex;
            gap: 15px;
        }

        .pack-preview-btn {
            flex: 1;
            padding: 15px;
            font-size: 1.2em;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pack-preview-btn.open {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .pack-preview-btn.cancel {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .pack-preview-btn:hover {
            transform: scale(1.05);
        }

        .question-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .question-modal.active {
            display: flex;
        }

        .question-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .question-title {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .question-text {
            font-size: 1.8em;
            margin: 30px 0;
            font-weight: bold;
        }

        .question-input {
            width: 100%;
            padding: 15px;
            font-size: 1.3em;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }

        .question-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .question-submit {
            padding: 15px 40px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .question-submit:hover {
            transform: scale(1.05);
        }

        .question-feedback {
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="authScreen" class="auth-screen">
            <div class="auth-container">
                <h1 style="text-align: center; margin-bottom: 30px;">‚öîÔ∏è Character Battle Arena</h1>
                
                <div class="auth-tabs">
                    <button class="auth-tab active" onclick="switchAuthTab('login')">Login</button>
                    <button class="auth-tab" onclick="switchAuthTab('register')">Register</button>
                </div>

                <div id="loginForm" class="auth-form">
                    <h2>Login to Your Account</h2>
                    <input type="text" id="loginUsername" placeholder="Username" class="auth-input" onkeypress="if(event.key==='Enter') handleLogin()">
                    <input type="password" id="loginPassword" placeholder="Password" class="auth-input" onkeypress="if(event.key==='Enter') handleLogin()">
                    <button class="auth-button" onclick="handleLogin()" type="button">üéÆ Login</button>
                    <div id="loginError" class="error-message"></div>
                </div>

                <div id="registerForm" class="auth-form" style="display: none;">
                    <h2>Create New Account</h2>
                    <input type="text" id="registerUsername" placeholder="Username (3-20 characters)" class="auth-input" onkeypress="if(event.key==='Enter') handleRegister()">
                    <input type="password" id="registerPassword" placeholder="Password (min 6 characters)" class="auth-input" onkeypress="if(event.key==='Enter') handleRegister()">
                    <input type="password" id="registerConfirmPassword" placeholder="Confirm Password" class="auth-input" onkeypress="if(event.key==='Enter') handleRegister()">
                    <button class="auth-button" onclick="handleRegister()" type="button">‚ú® Create Account</button>
                    <div id="registerError" class="error-message"></div>
                </div>
            </div>
        </div>

        <div id="modeSelectionScreen" class="mode-selection-screen">
            <div class="mode-selection-container">
                <div class="mode-selection-title">üéÆ Choose Your Game Mode</div>
                <div class="mode-selection-subtitle">Select how you want to play Character Battle Arena</div>
                
                <div class="mode-grid">
                    <div class="mode-option" onclick="selectGameMode('fun')">
                        <div class="mode-icon">üéâ</div>
                        <div class="mode-name">Fun Mode</div>
                        <div class="mode-description">Pure gameplay! Battle freely with all your powers.</div>
                    </div>
                    
                    <div class="mode-option" onclick="selectGameMode('math')">
                        <div class="mode-icon">üî¢</div>
                        <div class="mode-name">Math Mode</div>
                        <div class="mode-description">Answer math questions to unlock your powers in battle!</div>
                    </div>
                    
                    <div class="mode-option" onclick="selectGameMode('science')">
                        <div class="mode-icon">üî¨</div>
                        <div class="mode-name">Science Mode</div>
                        <div class="mode-description">Answer science questions to unlock your powers in battle!</div>
                    </div>
                    
                    <div class="mode-option" onclick="selectGameMode('logic')">
                        <div class="mode-icon">üß©</div>
                        <div class="mode-name">Logic Mode</div>
                        <div class="mode-description">Solve logic puzzles to unlock your powers in battle!</div>
                    </div>
                </div>
                
                <button id="confirmModeBtn" class="mode-confirm-btn" onclick="confirmGameMode()" disabled>
                    Start Game
                </button>
            </div>
        </div>

        <div id="gameStyleSelectionScreen" class="mode-selection-screen">
            <div class="mode-selection-container">
                <div class="mode-selection-title">üéØ Choose Your Game Style</div>
                <div class="mode-selection-subtitle">Select how you want to compete</div>
                
                <div class="mode-grid" style="grid-template-columns: repeat(2, 1fr);">
                    <div class="mode-option" onclick="selectGameStyle('normal')">
                        <div class="mode-icon">‚öîÔ∏è</div>
                        <div class="mode-name">Normal</div>
                        <div class="mode-description">Classic battle mode. Fight opponents and collect characters!</div>
                    </div>
                    
                    <div class="mode-option" onclick="selectGameStyle('battlestar-rush')">
                        <div class="mode-icon">‚≠ê</div>
                        <div class="mode-name">Battlestar Rush</div>
                        <div class="mode-description">Race to collect Battle Stars! Compete against a host in a timed challenge!</div>
                    </div>
                </div>
                
                <button id="confirmStyleBtn" class="mode-confirm-btn" onclick="confirmGameStyle()" disabled>
                    Begin Adventure
                </button>
            </div>
        </div>

        <div id="gameScreen" style="display: none;">
            <header>
                <h1>‚öîÔ∏è Character Battle Arena</h1>
                <div style="text-align: center; margin: 10px 0;">
                    <span style="font-size: 1.2em;">Welcome, <strong id="usernameDisplay"></strong>!</span>
                    <button class="mode-btn" onclick="handleLogout()" style="margin-left: 20px; padding: 8px 20px; font-size: 0.9em;">üö™ Logout</button>
                </div>
                <div class="mode-selector">
                    <button class="mode-btn online active" onclick="setMode('online')">üåê Online Mode</button>
                    <button class="mode-btn offline" onclick="setMode('offline')">üè† Offline Mode</button>
                </div>
            </header>

            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="coins">500</div>
                    <div class="stat-label">üí∞ Coins</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalCharacters">0</div>
                    <div class="stat-label">üë• Characters</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="winsCount">0</div>
                    <div class="stat-label">üèÜ Wins</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="worldsUnlocked">1</div>
                    <div class="stat-label">üåç Worlds</div>
                </div>
            </div>

            <!-- Home Page -->
            <div id="homePage" class="page-content">
                <div class="home-container">
                    <h2 style="text-align: center; font-size: 2.5em; margin-bottom: 40px;">üè† Main Menu</h2>
                    
                    <div class="home-buttons">
                        <button class="home-nav-btn" onclick="navigateTo('packs')">
                            <div class="home-nav-icon">üì¶</div>
                            <div class="home-nav-title">Open Packs</div>
                            <div class="home-nav-desc">Buy and open character packs</div>
                        </button>
                        
                        <button class="home-nav-btn" onclick="navigateTo('shop')">
                            <div class="home-nav-icon">üõí</div>
                            <div class="home-nav-title">Shop</div>
                            <div class="home-nav-desc">Buy upgrades and power-ups</div>
                        </button>
                        
                        <button class="home-nav-btn" onclick="navigateTo('collection')">
                            <div class="home-nav-icon">üë•</div>
                            <div class="home-nav-title">View Collection</div>
                            <div class="home-nav-desc">Browse your characters</div>
                        </button>
                        
                        <button class="home-nav-btn" onclick="navigateTo('battle')">
                            <div class="home-nav-icon">‚öîÔ∏è</div>
                            <div class="home-nav-title">Battle Arena</div>
                            <div class="home-nav-desc">Fight opponents and earn rewards</div>
                        </button>
                        
                        <button class="home-nav-btn" onclick="navigateTo('worlds')">
                            <div class="home-nav-icon">üåç</div>
                            <div class="home-nav-title">Explore Worlds</div>
                            <div class="home-nav-desc">Unlock and discover new worlds</div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Packs Page -->
            <div id="packsPage" class="page-content" style="display: none;">
                <div class="page-header">
                    <button class="back-btn" onclick="navigateTo('home')">‚Üê Back to Home</button>
                    <h2>üì¶ Character Packs</h2>
                </div>
                <div class="pack-grid" id="packGrid"></div>
            </div>

            <!-- Collection Page -->
            <div id="collectionPage" class="page-content" style="display: none;">
                <div class="page-header">
                    <button class="back-btn" onclick="navigateTo('home')">‚Üê Back to Home</button>
                    <h2>üë• Your Collection</h2>
                </div>
                <div class="filter-section">
                    <strong>Filter by Rarity:</strong><br>
                    <button class="filter-btn active" data-filter="all" onclick="filterByRarity('all')">All</button>
                    <button class="filter-btn" data-filter="common" onclick="filterByRarity('common')">Common</button>
                    <button class="filter-btn" data-filter="rare" onclick="filterByRarity('rare')">Rare</button>
                    <button class="filter-btn" data-filter="epic" onclick="filterByRarity('epic')">Epic</button>
                    <button class="filter-btn" data-filter="legendary" onclick="filterByRarity('legendary')">Legendary</button>
                    <button class="filter-btn" data-filter="mythic" onclick="filterByRarity('mythic')">Mythic+</button>
                </div>
                <div class="main-with-sidebar">
                    <div class="character-grid" id="characterGrid"></div>
                    <div class="sidebar-stats">
                        <div class="section-title">üìä Character Stats</div>
                        <div id="selectedCharacterStats">
                            <p style="opacity: 0.6; text-align: center; margin-top: 20px;">Select a character to view stats</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Battle Page -->
            <div id="battlePage" class="page-content" style="display: none;">
                <div class="page-header">
                    <button class="back-btn" onclick="navigateTo('home')">‚Üê Back to Home</button>
                    <h2>‚öîÔ∏è Battle Arena</h2>
                </div>
                <div id="battleContent"></div>
            </div>

            <!-- Worlds Page -->
            <div id="worldsPage" class="page-content" style="display: none;">
                <div class="page-header">
                    <button class="back-btn" onclick="navigateTo('home')">‚Üê Back to Home</button>
                    <h2>üåç Explore Worlds</h2>
                </div>
                <div class="world-grid" id="worldGrid"></div>
            </div>

            <!-- Shop Page -->
            <div id="shopPage" class="page-content" style="display: none;">
                <div class="page-header">
                    <button class="back-btn" onclick="navigateTo('home')">‚Üê Back to Home</button>
                    <h2>üõí Shop</h2>
                </div>
                <div id="shopContent"></div>
            </div>

            <!-- World Exploration Page -->
            <div id="explorationPage" class="page-content" style="display: none;">
                <div class="page-header">
                    <button class="back-btn" onclick="navigateTo('worlds')">‚Üê Back to Worlds</button>
                    <h2 id="explorationWorldTitle">üó∫Ô∏è World Exploration</h2>
                </div>
                <div id="explorationContent"></div>
            </div>
        </div>
    </div>

    <div id="battleScreen" class="battle-screen">
        <div id="battleBackground" class="world-bg-starter-plains">
            <button class="back-btn" onclick="exitBattle()">‚¨ÖÔ∏è Back to Game</button>
            
            <div class="battle-header">
                <div class="battle-world-name" id="battleWorldName">Starter Plains</div>
            </div>

            <div class="battle-container">
                <div id="turnIndicator" class="turn-indicator">Your Turn!</div>
                
                <div class="battle-fighters">
                    <div class="battle-fighter">
                        <div class="battle-fighter-icon" id="playerBattleIcon">üêï</div>
                        <div class="battle-fighter-name" id="playerBattleName">Your Character</div>
                        <div class="health-display">
                            <div class="health-label">
                                <span>HP</span>
                                <span id="playerBattleHP">100/100</span>
                            </div>
                            <div class="health-bar-large">
                                <div class="health-fill-large" id="playerBattleHealthFill" style="width: 100%;">
                                    <span id="playerHealthPercent">100%</span>
                                </div>
                            </div>
                        </div>
                        <div class="battle-fighter-stats">
                            <div class="stat-item">‚ö° Power: <span id="playerBattlePower">50</span></div>
                            <div class="stat-item">üî∞ Level: <span id="playerBattleLevel">1</span></div>
                        </div>
                        <div class="powers-section">
                            <div class="powers-title">‚öîÔ∏è Choose Your Power</div>
                            <div class="power-buttons" id="playerPowers"></div>
                        </div>
                    </div>

                    <div class="battle-vs">‚öîÔ∏è</div>

                    <div class="battle-fighter">
                        <div class="battle-fighter-icon" id="opponentBattleIcon">ü¶Å</div>
                        <div class="battle-fighter-name" id="opponentBattleName">Opponent</div>
                        <div class="health-display">
                            <div class="health-label">
                                <span>HP</span>
                                <span id="opponentBattleHP">100/100</span>
                            </div>
                            <div class="health-bar-large">
                                <div class="health-fill-large" id="opponentBattleHealthFill" style="width: 100%;">
                                    <span id="opponentHealthPercent">100%</span>
                                </div>
                            </div>
                        </div>
                        <div class="battle-fighter-stats">
                            <div class="stat-item">‚ö° Power: <span id="opponentBattlePower">50</span></div>
                            <div class="stat-item">üéØ Rarity: <span id="opponentBattleRarity">Common</span></div>
                        </div>
                        <div class="powers-section">
                            <div class="powers-title">ü§ñ AI Powers</div>
                            <div style="opacity: 0.6; padding: 20px; text-align: center;">Opponent will choose strategically...</div>
                        </div>
                    </div>
                </div>

                <div class="battle-action-log" id="battleActionLog"></div>
                
                <div id="battleResultScreen" style="display: none;"></div>
            </div>
        </div>
    </div>

    <div class="modal" id="packModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <div id="modalContent"></div>
        </div>
    </div>

    <div class="modal pack-preview-modal" id="packPreviewModal">
        <div class="modal-content pack-preview-content">
            <span class="modal-close" onclick="closePackPreview()">&times;</span>
            <div id="packPreviewContent"></div>
        </div>
    </div>

    <div id="questionModal" class="question-modal">
        <div class="question-content">
            <div class="question-title" id="questionTitle">Answer to Use Power!</div>
            <div class="question-text" id="questionText"></div>
            <input type="text" id="questionInput" class="question-input" placeholder="Enter your answer..." onkeypress="if(event.key==='Enter') submitAnswer()">
            <button class="question-submit" onclick="submitAnswer()">Submit Answer</button>
            <div class="question-feedback" id="questionFeedback"></div>
        </div>
    </div>

    <script>
        // Account Management System
        let currentUser = null;

        // Load accounts from localStorage
        function getAccounts() {
            const accounts = localStorage.getItem('battleArenaAccounts');
            return accounts ? JSON.parse(accounts) : {};
        }

        function saveAccounts(accounts) {
            localStorage.setItem('battleArenaAccounts', JSON.stringify(accounts));
        }

        function switchAuthTab(tab) {
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            
            if (tab === 'login') {
                document.querySelectorAll('.auth-tab')[0].classList.add('active');
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('registerForm').style.display = 'none';
            } else {
                document.querySelectorAll('.auth-tab')[1].classList.add('active');
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('registerForm').style.display = 'block';
            }
        }

        function handleRegister() {
            try {
                const username = document.getElementById('registerUsername').value.trim();
                const password = document.getElementById('registerPassword').value;
                const confirmPassword = document.getElementById('registerConfirmPassword').value;
                const errorDiv = document.getElementById('registerError');

                // Validation
                if (!username || !password || !confirmPassword) {
                    errorDiv.textContent = '‚ùå Please fill in all fields';
                    return;
                }

                if (username.length < 3 || username.length > 20) {
                    errorDiv.textContent = '‚ùå Username must be 3-20 characters';
                    return;
                }

                if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                    errorDiv.textContent = '‚ùå Username can only contain letters, numbers, and underscores';
                    return;
                }

                if (password.length < 6) {
                    errorDiv.textContent = '‚ùå Password must be at least 6 characters';
                    return;
                }

                if (password !== confirmPassword) {
                    errorDiv.textContent = '‚ùå Passwords do not match';
                    return;
                }

                const accounts = getAccounts();
                if (accounts[username]) {
                    errorDiv.textContent = '‚ùå Username already exists';
                    return;
                }

                // Create account
                accounts[username] = {
                    password: password,
                    createdAt: new Date().toISOString(),
                    gameState: {
                        mode: 'online',
                        coins: 500,
                        characters: [],
                        wins: 0,
                        currentWorld: 'Starter Plains',
                        unlockedWorlds: ['Starter Plains'],
                        battleStars: 0,
                        selectedGameMode: null,
                        selectedGameStyle: null,
                        questionDifficulty: 'medium'
                    }
                };

                saveAccounts(accounts);
                
                errorDiv.textContent = '';
                errorDiv.className = 'success-message';
                errorDiv.textContent = '‚úÖ Account created! Please login.';
                
                setTimeout(() => {
                    document.getElementById('registerUsername').value = '';
                    document.getElementById('registerPassword').value = '';
                    document.getElementById('registerConfirmPassword').value = '';
                    switchAuthTab('login');
                    document.getElementById('registerError').className = 'error-message';
                    document.getElementById('registerError').textContent = '';
                }, 1500);
            } catch (error) {
                // Silently handle any errors
                const errorDiv = document.getElementById('registerError');
                if (errorDiv) {
                    errorDiv.textContent = '‚ùå Registration failed. Please try again.';
                }
            }
        }

        function handleLogin() {
            try {
                const username = document.getElementById('loginUsername').value.trim();
                const password = document.getElementById('loginPassword').value;
                const errorDiv = document.getElementById('loginError');

                // Clear any previous errors
                errorDiv.textContent = '';

                if (!username || !password) {
                    errorDiv.textContent = '‚ùå Please enter username and password';
                    return;
                }

                const accounts = getAccounts();
                const account = accounts[username];

                if (!account) {
                    errorDiv.textContent = '‚ùå Account not found';
                    return;
                }

                if (account.password !== password) {
                    errorDiv.textContent = '‚ùå Incorrect password';
                    return;
                }

                // Login successful
                currentUser = username;
                
                // Load game state if it exists
                if (account.gameState) {
                    loadGameState(account.gameState);
                }
                
                // Hide auth screen
                document.getElementById('authScreen').style.display = 'none';
                
                // Check if user has already selected a game mode and style
                if (gameState.selectedGameMode && gameState.selectedGameStyle) {
                    // Go directly to game
                    document.getElementById('gameScreen').style.display = 'block';
                    document.getElementById('usernameDisplay').textContent = username;
                    setTimeout(() => {
                        init();
                        const modeBtn = gameState.mode === 'online' 
                            ? document.querySelector('.mode-btn.online') 
                            : document.querySelector('.mode-btn.offline');
                        if (modeBtn) {
                            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                            modeBtn.classList.add('active');
                        }
                    }, 100);
                } else if (gameState.selectedGameMode) {
                    // Show game style selection screen
                    document.getElementById('gameStyleSelectionScreen').classList.add('active');
                } else {
                    // Show mode selection screen
                    document.getElementById('modeSelectionScreen').classList.add('active');
                }
            } catch (error) {
                // Silently handle any errors
                const errorDiv = document.getElementById('loginError');
                if (errorDiv) {
                    errorDiv.textContent = '‚ùå Login failed. Please try again.';
                }
            }
        }

        function handleLogout() {
            if (confirm('Are you sure you want to logout? Your progress will be saved.')) {
                saveGameState();
                currentUser = null;
                
                document.getElementById('authScreen').style.display = 'flex';
                document.getElementById('gameScreen').style.display = 'none';
                document.getElementById('loginUsername').value = '';
                document.getElementById('loginPassword').value = '';
                document.getElementById('loginError').textContent = '';
            }
        }

        function loadGameState(savedState) {
            if (!savedState) return;
            
            gameState.mode = savedState.mode || 'online';
            gameState.coins = savedState.coins || 500;
            gameState.characters = savedState.characters || [];
            gameState.wins = savedState.wins || 0;
            gameState.currentWorld = savedState.currentWorld || 'Starter Plains';
            gameState.unlockedWorlds = savedState.unlockedWorlds || ['Starter Plains'];
            gameState.battleStars = savedState.battleStars || 0;
            gameState.selectedGameMode = savedState.selectedGameMode || null;
            gameState.selectedGameStyle = savedState.selectedGameStyle || null;
            gameState.questionDifficulty = savedState.questionDifficulty || 'medium';
            gameState.luckMultiplier = savedState.luckMultiplier || 1;
            gameState.luckyBlockUses = savedState.luckyBlockUses || 0;
            gameState.ownedTraits = savedState.ownedTraits || [];
            gameState.worldExplorations = savedState.worldExplorations || {};
            
            // Fix any characters that have health != power
            gameState.characters.forEach(char => {
                if (char.health !== char.power) {
                    char.health = char.power;
                }
            });
            
            // Sync worlds array with unlocked worlds
            worlds.forEach(world => {
                world.unlocked = gameState.unlockedWorlds.includes(world.name);
            });
        }

        function saveGameState() {
            if (!currentUser) return;
            
            const accounts = getAccounts();
            if (accounts[currentUser]) {
                accounts[currentUser].gameState = {
                    mode: gameState.mode,
                    coins: gameState.coins,
                    characters: gameState.characters,
                    wins: gameState.wins,
                    currentWorld: gameState.currentWorld,
                    unlockedWorlds: gameState.unlockedWorlds,
                    battleStars: gameState.battleStars,
                    selectedGameMode: gameState.selectedGameMode,
                    selectedGameStyle: gameState.selectedGameStyle,
                    questionDifficulty: gameState.questionDifficulty,
                    luckMultiplier: gameState.luckMultiplier,
                    luckyBlockUses: gameState.luckyBlockUses,
                    ownedTraits: gameState.ownedTraits,
                    worldExplorations: gameState.worldExplorations
                };
                saveAccounts(accounts);
            }
        }

        // Auto-save every 30 seconds
        setInterval(() => {
            if (currentUser) {
                saveGameState();
            }
        }, 30000);

        // Mode selection functions
        let tempSelectedMode = null;

        function selectGameMode(mode) {
            tempSelectedMode = mode;
            
            // Update UI to show selection
            document.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.closest('.mode-option').classList.add('selected');
            
            // Enable confirm button
            document.getElementById('confirmModeBtn').disabled = false;
        }

        function confirmGameMode() {
            if (!tempSelectedMode) return;
            
            gameState.selectedGameMode = tempSelectedMode;
            saveGameState();
            
            // Hide mode selection and show game style selection
            document.getElementById('modeSelectionScreen').classList.remove('active');
            document.getElementById('gameStyleSelectionScreen').classList.add('active');
        }

        // Game style selection functions
        let tempSelectedStyle = null;

        function selectGameStyle(style) {
            tempSelectedStyle = style;
            
            // Update UI to show selection
            document.querySelectorAll('#gameStyleSelectionScreen .mode-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.closest('.mode-option').classList.add('selected');
            
            // Enable confirm button
            document.getElementById('confirmStyleBtn').disabled = false;
        }

        function confirmGameStyle() {
            if (!tempSelectedStyle) return;
            
            gameState.selectedGameStyle = tempSelectedStyle;
            saveGameState();
            
            // Hide style selection and show game
            document.getElementById('gameStyleSelectionScreen').classList.remove('active');
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('usernameDisplay').textContent = currentUser;
            
            setTimeout(() => {
                init();
                const modeBtn = gameState.mode === 'online' 
                    ? document.querySelector('.mode-btn.online') 
                    : document.querySelector('.mode-btn.offline');
                if (modeBtn) {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    modeBtn.classList.add('active');
                }
            }, 100);
        }

        // Shop Items
        const shopItems = [
            {
                id: 'lucky-block',
                name: 'Lucky Block',
                icon: 'üçÄ',
                description: 'Doubles your luck for the next 10 pack openings! 2x chance for rare characters.',
                price: 2500,
                type: 'upgrade',
                effect: 'luckMultiplier',
                uses: 10
            },
            {
                id: 'supreme-trait',
                name: 'Supreme Trait',
                icon: 'üëë',
                description: 'Ultimate power boost! +50 Power, adds 2 random pack advantages.',
                price: 2000,
                type: 'trait',
                powerBoost: 50,
                strengthsAdded: 2
            },
            {
                id: 'rainbow-trait',
                name: 'Rainbow Trait',
                icon: 'üåà',
                description: 'Powerful rainbow energy! +40 Power, adds 2 random pack advantages.',
                price: 1500,
                type: 'trait',
                powerBoost: 40,
                strengthsAdded: 2
            },
            {
                id: 'elemental-trait',
                name: 'Elemental Trait',
                icon: '‚ö°',
                description: 'Harness elemental power! +30 Power, adds 1 random pack advantage.',
                price: 1000,
                type: 'trait',
                powerBoost: 30,
                strengthsAdded: 1
            },
            {
                id: 'dust-trait',
                name: 'Dust Trait',
                icon: '‚ú®',
                description: 'Mystical dust enhancement! +20 Power, adds 1 random pack advantage.',
                price: 500,
                type: 'trait',
                powerBoost: 20,
                strengthsAdded: 1
            }
        ];

        // Game state
        const gameState = {
            mode: 'online',
            coins: 500,
            characters: [],
            wins: 0,
            currentWorld: 'Starter Plains',
            unlockedWorlds: ['Starter Plains'],
            battleStars: 0,
            selectedCharacter: null,
            currentFilter: 'all',
            selectedGameMode: null, // fun, math, science, logic
            selectedGameStyle: null, // normal, battlestar-rush
            questionDifficulty: 'medium', // easy, medium, hard
            currentTournament: null, // Tournament data if active
            luckMultiplier: 1, // Default 1x, 2x with Lucky Block
            luckyBlockUses: 0, // Number of pack openings with 2x luck remaining
            ownedTraits: [], // Array of owned traits {type, count}
            worldExplorations: {} // World exploration data {worldName: {resources, rescuedCharacters, homes, etc}}
        };

        // Rarities with drop rates
        const rarities = [
            { name: 'common', rate: 20, color: '#808080', sellPrice: 10 },
            { name: 'uncommon', rate: 16, color: '#00ff00', sellPrice: 25 },
            { name: 'rare', rate: 13, color: '#0080ff', sellPrice: 50 },
            { name: 'epic', rate: 11, color: '#a020f0', sellPrice: 100 },
            { name: 'legendary', rate: 9, color: '#ffa500', sellPrice: 200 },
            { name: 'ancient', rate: 8, color: '#ff0000', sellPrice: 400 },
            { name: 'extreme', rate: 7, color: '#ff1493', sellPrice: 800 },
            { name: 'mythic', rate: 6, color: '#00ffff', sellPrice: 1500 },
            { name: 'honorable', rate: 5, color: '#ffd700', sellPrice: 3000 },
            { name: 'master-class', rate: 3, color: '#ff69b4', sellPrice: 5000 },
            { name: 'insane', rate: 1.5, color: '#8b00ff', sellPrice: 10000 },
            { name: 'victorious', rate: 0.5, color: '#ffffff', sellPrice: 20000 }
        ];

        // Pack definitions
        const packs = [
            { 
                name: 'Pet Pack', 
                icon: 'üêï', 
                cost: 100,
                characters: {
                    common: ['üêï', 'üêà', 'üêá'],      // Dog, Cat, Rabbit
                    ancient: ['üêæ', 'üì±'],            // Pocket Pet, Digital Pet
                    honorable: ['üë®‚Äçüè´']                // Teacher's Pet
                },
                strengths: ['Crazy Pack'],  // Loyalty beats chaos
                weaknesses: ['Animal Pack']  // Wild animals overpower pets
            },
            { 
                name: 'Animal Pack', 
                icon: 'ü¶Å', 
                cost: 150,
                characters: {
                    common: ['ü¶Å', 'üêØ', 'üêò'],      // Lion, Tiger, Elephant
                    ancient: ['ü¶ñ', 'üê≤'],            // Dinosaur, Dragon
                    honorable: ['üëë']                // Crown/King Beast
                },
                strengths: ['Pet Pack', 'House Pack'],  // Animals destroy pets and structures
                weaknesses: ['Ice Monster Pack', 'Fire Monster Pack']  // Extreme temperatures hurt animals
            },
            { 
                name: 'Seasonal Pack', 
                icon: 'üéÉ', 
                cost: 120,
                characters: {
                    common: ['üéÉ', 'üéÑ', 'üå∏'],      // Pumpkin, Christmas Tree, Cherry Blossom
                    ancient: ['üåô', '‚≠ê'],            // Moon, Star
                    honorable: ['üí´']                // Shooting Star
                },
                strengths: ['House Pack', 'Tropic Pack'],  // Seasons change everything
                weaknesses: ['Crazy Pack']  // Chaos disrupts seasonal cycles
            },
            { 
                name: 'House Pack', 
                icon: 'üè†', 
                cost: 100,
                characters: {
                    common: ['üè†', 'üè∞', 'üèõÔ∏è'],      // House, Castle, Temple
                    ancient: ['üóø', 'üïå'],            // Moai, Mosque
                    honorable: ['üåê']                // Globe
                },
                strengths: ['Ice Monster Pack', 'Seaside Pack'],  // Shelter protects from elements
                weaknesses: ['Animal Pack', 'Seasonal Pack']  // Animals and weather destroy buildings
            },
            { 
                name: 'Fire Monster Pack', 
                icon: 'üî•', 
                cost: 200,
                characters: {
                    common: ['üî•', 'üåã', 'üêâ'],      // Fire, Volcano, Dragon
                    ancient: ['‚òÑÔ∏è', 'üí•'],            // Comet, Explosion
                    honorable: ['‚ö°']                // Lightning
                },
                strengths: ['Ice Monster Pack', 'Tropic Pack', 'Animal Pack'],  // Fire melts ice, burns plants/animals
                weaknesses: ['Seaside Pack']  // Water extinguishes fire
            },
            { 
                name: 'Ice Monster Pack', 
                icon: '‚ùÑÔ∏è', 
                cost: 200,
                characters: {
                    common: ['‚ùÑÔ∏è', '‚õÑ', 'üßä'],      // Snowflake, Snowman, Ice Cube
                    ancient: ['üíé', 'üî∑'],            // Diamond, Blue Diamond
                    honorable: ['üí†']                // Diamond Shape
                },
                strengths: ['Seaside Pack', 'Animal Pack', 'Tropic Pack'],  // Ice freezes water, slows animals/plants
                weaknesses: ['Fire Monster Pack', 'House Pack']  // Fire melts ice, shelter blocks cold
            },
            { 
                name: 'Tropic Pack', 
                icon: 'üå¥', 
                cost: 130,
                characters: {
                    common: ['üå¥', 'ü¶ú', 'üå∫'],      // Palm Tree, Parrot, Hibiscus
                    ancient: ['ü¶ã', 'üåø'],            // Butterfly, Herb
                    honorable: ['üåç']                // Earth
                },
                strengths: ['Seaside Pack', 'Pet Pack'],  // Plants absorb water, entangle pets
                weaknesses: ['Fire Monster Pack', 'Ice Monster Pack']  // Fire burns, ice freezes plants
            },
            { 
                name: 'Seaside Pack', 
                icon: 'üåä', 
                cost: 140,
                characters: {
                    common: ['üåä', 'ü¶à', 'üêô'],      // Wave, Shark, Octopus
                    ancient: ['üî±', '‚öì'],            // Trident, Anchor
                    honorable: ['üåÄ']                // Cyclone
                },
                strengths: ['Fire Monster Pack', 'Crazy Pack'],  // Water douses fire, flow beats chaos
                weaknesses: ['Ice Monster Pack', 'Tropic Pack', 'House Pack']  // Ice freezes water, plants absorb it, shelter blocks it
            },
            { 
                name: 'Crazy Pack', 
                icon: 'ü§™', 
                cost: 250,
                characters: {
                    common: ['ü§™', 'üëΩ', 'ü§ñ'],      // Crazy Face, Alien, Robot
                    ancient: ['üåå', 'üé≠'],            // Galaxy, Theater Masks
                    honorable: ['‚ôæÔ∏è']                // Infinity
                },
                strengths: ['Seasonal Pack', 'Animal Pack', 'House Pack'],  // Chaos disrupts order
                weaknesses: ['Pet Pack', 'Seaside Pack']  // Loyalty and flow counter chaos
            }
        ];

        // Function to get the appropriate character icon based on rarity
        function getCharacterIcon(pack, rarity) {
            const rarityIndex = rarities.findIndex(r => r.name === rarity);
            
            // Honorable-Victorious (indices 8-11): use honorable tier
            if (rarityIndex >= 8) {
                const chars = pack.characters.honorable;
                return chars[0]; // Single character for top tier
            }
            // Ancient-Mythic (indices 5-7): use ancient tier
            else if (rarityIndex >= 5) {
                const chars = pack.characters.ancient;
                return chars[Math.floor(Math.random() * chars.length)];
            }
            // Common-Legendary (indices 0-4): use common tier
            else {
                const chars = pack.characters.common;
                return chars[Math.floor(Math.random() * chars.length)];
            }
        }

        // Worlds
        const worlds = [
            { name: 'Starter Plains', requirement: 0, unlocked: true },
            { name: 'Forest Kingdom', requirement: 5, unlocked: false },
            { name: 'Desert Ruins', requirement: 15, unlocked: false },
            { name: 'Ice Caverns', requirement: 30, unlocked: false },
            { name: 'Volcano Peak', requirement: 50, unlocked: false },
            { name: 'Ocean Depths', requirement: 75, unlocked: false },
            { name: 'Sky Castle', requirement: 100, unlocked: false },
            { name: 'Shadow Realm', requirement: 150, unlocked: false },
            { name: 'Crystal Dimension', requirement: 200, unlocked: false },
            { name: 'Ultimate Arena', requirement: 300, unlocked: false }
        ];

        // Initialize game
        function init() {
            try {
                // Check if elements exist before trying to render
                if (!document.getElementById('packGrid')) {
                    return;
                }
                renderPacks();
                updateStats();
                
                // Show home page initially
                navigateTo('home');
            } catch (error) {
                // Silently handle initialization errors
            }
        }

        function renderPacks() {
            const grid = document.getElementById('packGrid');
            if (!grid) return;
            grid.innerHTML = packs.map(pack => `
                <div class="pack-card" onclick="openPack('${pack.name}')">
                    <div class="pack-icon">${pack.icon}</div>
                    <div class="pack-name">${pack.name}</div>
                    <div class="pack-cost">üí∞ ${pack.cost}</div>
                </div>
            `).join('');
        }

        function getRarity() {
            const rand = Math.random() * 100;
            let cumulative = 0;
            
            // Apply luck multiplier - makes rare characters more likely
            const luckMultiplier = gameState.luckMultiplier || 1;
            
            for (let i = 0; i < rarities.length; i++) {
                const rarity = rarities[i];
                let adjustedRate = rarity.rate;
                
                // If luck is 2x, boost rare rarity rates more
                if (luckMultiplier > 1 && i >= 4) { // Legendary and above (index 4+)
                    adjustedRate *= luckMultiplier;
                }
                
                cumulative += adjustedRate;
                if (rand <= cumulative) return rarity.name;
            }
            return 'common';
        }

        // Shop Functions
        function renderShop() {
            const shopContent = document.getElementById('shopContent');
            if (!shopContent) return;
            
            // Show Lucky Block status if active
            let luckyBlockHTML = '';
            if (gameState.luckyBlockUses > 0) {
                luckyBlockHTML = `
                    <div class="trait-inventory" style="border: 3px solid #ffd700;">
                        <h3 style="margin-bottom: 15px;">üçÄ Lucky Block Active!</h3>
                        <p style="font-size: 1.3em; color: #ffd700;">
                            <strong>${gameState.luckyBlockUses}</strong> lucky pack openings remaining
                        </p>
                        <p style="margin-top: 10px; opacity: 0.8;">2x chance for rare characters!</p>
                    </div>
                `;
            }
            
            // Show trait inventory if player has traits
            let inventoryHTML = '';
            if (gameState.ownedTraits.length > 0) {
                inventoryHTML = `
                    <div class="trait-inventory">
                        <h3 style="margin-bottom: 15px;">üì¶ Your Trait Inventory</h3>
                        <div>
                            ${gameState.ownedTraits.map(trait => {
                                const item = shopItems.find(si => si.id === trait.type);
                                return `<span class="trait-badge">${item.icon} ${item.name} x${trait.count}</span>`;
                            }).join('')}
                        </div>
                        <p style="margin-top: 15px; opacity: 0.8;">Apply traits to your characters from their stats page!</p>
                    </div>
                `;
            }
            
            shopContent.innerHTML = `
                ${luckyBlockHTML}
                ${inventoryHTML}
                <div class="shop-grid">
                    ${shopItems.map(item => {
                        const canAfford = gameState.coins >= item.price;
                        const isDisabled = !canAfford;
                        
                        return `
                            <div class="shop-item">
                                <div class="shop-item-icon">${item.icon}</div>
                                <div class="shop-item-name">${item.name}</div>
                                <div class="shop-item-desc">${item.description}</div>
                                <div class="shop-item-price">üí∞ ${item.price} Coins</div>
                                <button class="shop-buy-btn" ${isDisabled ? 'disabled' : ''} onclick="buyShopItem('${item.id}')">
                                    ${canAfford ? 'Buy Now' : 'Not Enough Coins'}
                                </button>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function buyShopItem(itemId) {
            const item = shopItems.find(si => si.id === itemId);
            if (!item) return;
            
            // Check if can afford
            if (gameState.coins < item.price) {
                alert('Not enough coins!');
                return;
            }
            
            // Deduct coins
            gameState.coins -= item.price;
            
            if (item.type === 'upgrade') {
                // Apply upgrade
                if (item.effect === 'luckMultiplier') {
                    gameState.luckyBlockUses += item.uses || 10;
                    gameState.luckMultiplier = 2;
                    alert(`${item.icon} Lucky Block purchased! You have ${gameState.luckyBlockUses} lucky pack openings with 2x chance!`);
                }
            } else if (item.type === 'trait') {
                // Add trait to inventory
                const existingTrait = gameState.ownedTraits.find(t => t.type === itemId);
                if (existingTrait) {
                    existingTrait.count++;
                } else {
                    gameState.ownedTraits.push({ type: itemId, count: 1 });
                }
                alert(`${item.icon} ${item.name} purchased! Apply it to a character from your collection.`);
            }
            
            saveGameState();
            updateStats();
            renderShop();
        }

        function applyTraitToCharacter(characterId, traitId) {
            const character = gameState.characters.find(c => c.id === characterId);
            const traitInventory = gameState.ownedTraits.find(t => t.type === traitId);
            const traitItem = shopItems.find(si => si.id === traitId);
            
            if (!character || !traitInventory || traitInventory.count <= 0 || !traitItem) {
                alert('Cannot apply trait!');
                return;
            }
            
            // Check if character already has a trait
            if (character.appliedTrait) {
                if (!confirm(`This character already has ${character.appliedTrait}. Replace it?`)) {
                    return;
                }
            }
            
            // Apply trait
            character.appliedTrait = traitId;
            character.power += traitItem.powerBoost;
            character.health = character.power;  // Update health to match new power
            
            // Add random pack strengths
            if (!character.bonusStrengths) {
                character.bonusStrengths = [];
            }
            
            // Get random packs to be strong against
            const availablePacks = packs.filter(p => p.name !== character.packName);
            for (let i = 0; i < traitItem.strengthsAdded; i++) {
                if (availablePacks.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availablePacks.length);
                    const randomPack = availablePacks.splice(randomIndex, 1)[0];
                    character.bonusStrengths.push(randomPack.name);
                }
            }
            
            // Decrease trait count
            traitInventory.count--;
            if (traitInventory.count === 0) {
                gameState.ownedTraits = gameState.ownedTraits.filter(t => t.type !== traitId);
            }
            
            saveGameState();
            alert(`${traitItem.icon} ${traitItem.name} applied to ${character.name}!\n+${traitItem.powerBoost} Power\n+${traitItem.strengthsAdded} Bonus Advantages`);
            renderCharacters();
            selectCharacter(characterId); // Refresh the stats display
        }

        function openPack(packName) {
            const pack = packs.find(p => p.name === packName);
            if (gameState.coins < pack.cost) {
                alert('Not enough coins!');
                return;
            }

            // Show pack preview
            showPackPreview(packName);
        }

        function showPackPreview(packName) {
            const pack = packs.find(p => p.name === packName);
            const modal = document.getElementById('packPreviewModal');
            const content = document.getElementById('packPreviewContent');
            
            // Generate preview of all possible characters by rarity tier
            let previewHTML = `
                <div class="pack-preview-header">
                    <div class="pack-preview-icon">${pack.icon}</div>
                    <div class="pack-preview-title">${packName}</div>
                    <p style="font-size: 1.2em; margin-top: 10px;">Cost: üí∞ ${pack.cost} coins</p>
                    <p style="font-size: 0.95em; opacity: 0.8; margin-top: 5px;">Different characters at different rarities!</p>
                </div>
                <div class="characters-preview">
                    <h3 style="text-align: center; margin-bottom: 15px;">Possible Characters & Drop Rates:</h3>
            `;
            
            // Show all characters across all rarity tiers
            rarities.forEach((rarity, index) => {
                const rarityColor = rarity.color;
                const icon = getCharacterIcon(pack, rarity.name);
                const names = characterNamesByIcon[packName]?.[icon]?.[rarity.name];
                const exampleName = names && names.length > 0 ? names[0] : 'Unknown';
                
                previewHTML += `
                    <div class="character-preview-item" style="border-left-color: ${rarityColor};">
                        <div class="character-preview-left">
                            <div class="character-preview-icon">${icon}</div>
                            <div class="character-preview-info">
                                <div class="character-preview-name" style="color: ${rarityColor};">
                                    ${exampleName}
                                </div>
                                <div class="character-preview-rarity">${rarity.name.toUpperCase()}</div>
                            </div>
                        </div>
                        <div class="character-preview-chance" style="color: ${rarityColor};">
                            ${rarity.rate}%
                        </div>
                    </div>
                `;
            });
            
            previewHTML += `
                </div>
                <div class="pack-preview-buttons">
                    <button class="pack-preview-btn cancel" onclick="closePackPreview()">Cancel</button>
                    <button class="pack-preview-btn open" onclick="confirmOpenPack('${packName}')">
                        Open for ${pack.cost} üí∞
                    </button>
                </div>
            `;
            
            content.innerHTML = previewHTML;
            modal.classList.add('active');
        }

        function closePackPreview() {
            document.getElementById('packPreviewModal').classList.remove('active');
        }

        function confirmOpenPack(packName) {
            const pack = packs.find(p => p.name === packName);
            
            // Close preview modal
            closePackPreview();
            
            // Deduct coins
            gameState.coins -= pack.cost;
            saveGameState();
            
            // Show pack opening modal
            const modal = document.getElementById('packModal');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="pack-opening">
                    <h2>Opening ${packName}...</h2>
                    <div class="pack-animation">${pack.icon}</div>
                    <button class="battle-btn" onclick="revealCharacter('${packName}')">Open Pack!</button>
                </div>
            `;
            
            modal.classList.add('active');
            updateStats();
        }

        // Character names by pack, icon, and rarity
        const characterNamesByIcon = {
            'Pet Pack': {
                'üêï': {
                    common: ['Buddy', 'Pup', 'Spot', 'Fido'],
                    uncommon: ['Max', 'Duke', 'Rex', 'Charlie'],
                    rare: ['Thunder Paw', 'Shadow Wolf', 'Storm Runner', 'Blazing Hound'],
                    epic: ['Cerberus Jr', 'Moon Howler', 'Alpha King', 'Spirit Guardian'],
                    legendary: ['Fenrir', 'Anubis Guard', 'Celestial Hound', 'Phantom Beast'],
                    ancient: ['Cosmic Guardian', 'Eternal Protector', 'Void Stalker', 'Time Walker'],
                    extreme: ['Dimensional Warden', 'Reality Bender', 'Chaos Hound', 'Astral Emperor'],
                    mythic: ['Omniscient Sentinel', 'Universe Keeper', 'Infinity Wolf', 'Creation Beast'],
                    honorable: ['Divine Arbiter', 'Sacred Champion', 'Legendary Hero', 'Noble Paragon'],
                    'master-class': ['Supreme Overlord', 'Ultimate Alpha', 'Grand Sovereign', 'Perfect Being'],
                    insane: ['Transcendent Entity', 'Beyond God', 'Impossible One', 'Unthinkable Force'],
                    victorious: ['The Eternal Victor', 'Undefeated Legend', 'Supreme Conqueror', 'Ultimate Champion']
                },
                'üêà': {
                    common: ['Kitty', 'Whiskers', 'Mittens', 'Shadow'],
                    uncommon: ['Luna', 'Felix', 'Tiger', 'Simba'],
                    rare: ['Night Stalker', 'Midnight Prowler', 'Phantom Claw', 'Moon Shadow'],
                    epic: ['Bastet\'s Chosen', 'Eclipse Feline', 'Void Cat', 'Spirit Panther'],
                    legendary: ['Nine Lives Master', 'Eternal Hunter', 'Cosmic Feline', 'Shadow Deity'],
                    ancient: ['First Predator', 'Primordial Prowler', 'Dawn Hunter', 'Origin Stalker'],
                    extreme: ['Reality Stalker', 'Dimensional Cat', 'Void Predator', 'Cosmic Prowler'],
                    mythic: ['Universal Hunter', 'Infinite Shadow', 'Creation\'s Watcher', 'Eternal Feline'],
                    honorable: ['Sacred Cat', 'Holy Guardian', 'Divine Protector', 'Blessed Hunter'],
                    'master-class': ['Supreme Predator', 'Perfect Stalker', 'Ultimate Feline', 'Absolute Hunter'],
                    insane: ['Beyond Nature', 'Impossible Cat', 'The Unseeable', 'Pure Shadow'],
                    victorious: ['Never Caught', 'Eternal Prowler', 'Undefeated Hunter', 'Supreme Feline']
                },
                'üêá': {
                    common: ['Fluffy', 'Hoppy', 'Cotton', 'Bunny'],
                    uncommon: ['Thumper', 'Clover', 'Spring', 'Dash'],
                    rare: ['Lightning Hop', 'Speed Demon', 'Turbo Bunny', 'Velocity Hare'],
                    epic: ['Time Jumper', 'Warp Rabbit', 'Infinite Hopper', 'Space Leaper'],
                    legendary: ['White Rabbit', 'Lunar Hare', 'Cosmic Bunny', 'Stellar Hopper'],
                    ancient: ['First Hop', 'Primordial Rabbit', 'Dawn Leaper', 'Origin Hare'],
                    extreme: ['Reality Hopper', 'Dimensional Rabbit', 'Void Bunny', 'Cosmic Jumper'],
                    mythic: ['Universal Leaper', 'Infinite Hop', 'Creation\'s Messenger', 'Eternal Rabbit'],
                    honorable: ['Sacred Hare', 'Holy Hopper', 'Divine Rabbit', 'Blessed Leaper'],
                    'master-class': ['Supreme Bunny', 'Perfect Hopper', 'Ultimate Rabbit', 'Absolute Hare'],
                    insane: ['Beyond Speed', 'Impossible Hop', 'The Uncatchable', 'Pure Velocity'],
                    victorious: ['Never Stopped', 'Eternal Runner', 'Undefeated Hare', 'Supreme Hopper']
                },
                'üêæ': {
                    common: ['Tiny', 'Mini', 'Pocket', 'Small'],
                    uncommon: ['Compact', 'Portable', 'Mobile', 'Handy'],
                    rare: ['Micro Beast', 'Nano Creature', 'Particle Pet', 'Quantum Friend'],
                    epic: ['Atom Companion', 'Molecule Buddy', 'Subatomic Pal', 'Quark Pet'],
                    legendary: ['Planck Protector', 'String Theory Pet', 'Dark Matter Friend', 'Higgs Companion'],
                    ancient: ['First Particle', 'Primordial Atom', 'Dawn Molecule', 'Origin Quantum'],
                    extreme: ['Reality Fragment', 'Dimensional Particle', 'Void Atom', 'Cosmic Quark'],
                    mythic: ['Universal Particle', 'Infinite Small', 'Creation\'s Atom', 'Eternal Micro'],
                    honorable: ['Sacred Pocket Pet', 'Holy Miniature', 'Divine Tiny One', 'Blessed Particle'],
                    'master-class': ['Supreme Micro', 'Perfect Atom', 'Ultimate Particle', 'Absolute Quantum'],
                    insane: ['Beyond Size', 'Impossible Small', 'The Infinitesimal', 'Pure Particle'],
                    victorious: ['Never Lost', 'Eternal Companion', 'Undefeated Pocket', 'Supreme Micro']
                },
                'üì±': {
                    common: ['Pixel', 'Byte', 'Data', 'Code'],
                    uncommon: ['Binary', 'Chip', 'Circuit', 'Program'],
                    rare: ['Cyber Pet', 'Virtual Friend', 'AI Companion', 'Digital Beast'],
                    epic: ['Neural Network', 'Quantum Computer', 'Cloud Creature', 'Matrix Pet'],
                    legendary: ['Singularity Pet', 'AGI Companion', 'Digital God', 'Virtual Deity'],
                    ancient: ['First Code', 'Primordial Data', 'Dawn Algorithm', 'Origin Program'],
                    extreme: ['Reality Code', 'Dimensional Data', 'Void Program', 'Cosmic Algorithm'],
                    mythic: ['Universal Code', 'Infinite Data', 'Creation\'s Program', 'Eternal Algorithm'],
                    honorable: ['Sacred Data', 'Holy Code', 'Divine Program', 'Blessed Algorithm'],
                    'master-class': ['Supreme AI', 'Perfect Code', 'Ultimate Program', 'Absolute Data'],
                    insane: ['Beyond Binary', 'Impossible Code', 'The Uncomputable', 'Pure Information'],
                    victorious: ['Never Deleted', 'Eternal Code', 'Undefeated Data', 'Supreme Program']
                },
                'üë®‚Äçüè´': {
                    common: ['Helper', 'Good Student', 'Assistant', 'Favorite'],
                    uncommon: ['Star Pupil', 'Class Leader', 'Top Student', 'Best Helper'],
                    rare: ['Perfect Scholar', 'Knowledge Keeper', 'Wisdom Bearer', 'Study Master'],
                    epic: ['Academic Supreme', 'Learning Legend', 'Education Emperor', 'Scholar King'],
                    legendary: ['Socratic Pet', 'Confucian Companion', 'Aristotle\'s Friend', 'Da Vinci\'s Pupil'],
                    ancient: ['First Teacher', 'Primordial Knowledge', 'Dawn Wisdom', 'Origin Scholar'],
                    extreme: ['Reality Learner', 'Dimensional Scholar', 'Void Knowledge', 'Cosmic Wisdom'],
                    mythic: ['Universal Teacher', 'Infinite Knowledge', 'Creation\'s Student', 'Eternal Scholar'],
                    honorable: ['Sacred Teacher\'s Pet', 'Holy Scholar', 'Divine Student', 'Blessed Learner'],
                    'master-class': ['Supreme Scholar', 'Perfect Student', 'Ultimate Teacher\'s Pet', 'Absolute Knowledge'],
                    insane: ['Beyond Learning', 'Impossible Knowledge', 'The Omniscient', 'Pure Wisdom'],
                    victorious: ['Never Failed', 'Eternal Scholar', 'Undefeated Student', 'Supreme Teacher\'s Pet']
                }
            },
            'Animal Pack': {
                'ü¶Å': {
                    common: ['Leo', 'Simba', 'Pride', 'Roar'],
                    uncommon: ['King', 'Mufasa', 'Monarch', 'Chief'],
                    rare: ['Thunder Mane', 'Golden Claw', 'Savanna Lord', 'Wild King'],
                    epic: ['Pride Emperor', 'Jungle Sovereign', 'Apex Predator', 'Royal Beast'],
                    legendary: ['Aslan the Great', 'Celestial Lion', 'Eternal Monarch', 'Mythic Pride'],
                    ancient: ['Primordial Roar', 'Ancient Guardian', 'First King', 'Dawn Sovereign'],
                    extreme: ['Reality Shaper', 'Dimensional Pride', 'Cosmic Predator', 'Void Emperor'],
                    mythic: ['Infinite Roar', 'Universal Sovereign', 'Creation King', 'Eternal Dominion'],
                    honorable: ['Sacred Beast', 'Holy Protector', 'Divine Majesty', 'Blessed King'],
                    'master-class': ['Supreme Apex', 'Perfect Hunter', 'Ultimate Sovereign', 'Absolute Monarch'],
                    insane: ['Beyond Nature', 'Impossible Predator', 'Unfathomable Power', 'The Unreal'],
                    victorious: ['Never Defeated', 'Eternal Victor', 'Supreme Winner', 'Ultimate Triumph']
                },
                'üêØ': {
                    common: ['Stripes', 'Tiger', 'Bengal', 'Rajah'],
                    uncommon: ['Hunter', 'Prowler', 'Stealth', 'Shadow'],
                    rare: ['Orange Fury', 'Striped Terror', 'Jungle Stalker', 'Silent Death'],
                    epic: ['Bengal Lord', 'Siberian Emperor', 'White Tiger', 'Royal Hunter'],
                    legendary: ['Shere Khan', 'Tiger God', 'Celestial Feline', 'Mythic Stalker'],
                    ancient: ['First Stripes', 'Primordial Tiger', 'Dawn Predator', 'Origin Hunter'],
                    extreme: ['Reality Stalker', 'Dimensional Tiger', 'Void Hunter', 'Cosmic Stripes'],
                    mythic: ['Universal Tiger', 'Infinite Prowler', 'Creation\'s Hunter', 'Eternal Feline'],
                    honorable: ['Sacred Tiger', 'Holy Prowler', 'Divine Hunter', 'Blessed Stripes'],
                    'master-class': ['Supreme Tiger', 'Perfect Stalker', 'Ultimate Hunter', 'Absolute Predator'],
                    insane: ['Beyond Stripes', 'Impossible Tiger', 'The Unseen Hunter', 'Pure Stealth'],
                    victorious: ['Never Escaped', 'Eternal Hunter', 'Undefeated Tiger', 'Supreme Predator']
                },
                'üêª': {
                    common: ['Bear', 'Grizzly', 'Kodiak', 'Bruno'],
                    uncommon: ['Giant', 'Mighty', 'Strong', 'Powerful'],
                    rare: ['Thunder Bear', 'Mountain King', 'Forest Giant', 'Claw Master'],
                    epic: ['Polar Lord', 'Grizzly Emperor', 'Panda Sovereign', 'Bear God'],
                    legendary: ['Great Bear', 'Ursa Major', 'Constellation Bear', 'Star Guardian'],
                    ancient: ['First Bear', 'Primordial Giant', 'Dawn Strength', 'Origin Power'],
                    extreme: ['Reality Crusher', 'Dimensional Bear', 'Void Giant', 'Cosmic Strength'],
                    mythic: ['Universal Bear', 'Infinite Power', 'Creation\'s Guardian', 'Eternal Giant'],
                    honorable: ['Sacred Bear', 'Holy Guardian', 'Divine Protector', 'Blessed Giant'],
                    'master-class': ['Supreme Bear', 'Perfect Strength', 'Ultimate Guardian', 'Absolute Power'],
                    insane: ['Beyond Strength', 'Impossible Bear', 'The Unstoppable', 'Pure Power'],
                    victorious: ['Never Fallen', 'Eternal Guardian', 'Undefeated Bear', 'Supreme Giant']
                },
                'ü¶ñ': {
                    common: ['Rex', 'Dino', 'Raptor', 'Fossil'],
                    uncommon: ['Predator', 'Ancient One', 'Prehistoric', 'Mesozoic'],
                    rare: ['T-Rex King', 'Velociraptor', 'Mega Dinosaur', 'Jurassic Lord'],
                    epic: ['Apex Dinosaur', 'Extinction Survivor', 'Time Beast', 'Prehistoric God'],
                    legendary: ['Tyrannosaurus Emperor', 'Dinosaur King', 'Ancient Ruler', 'Mesozoic Monarch'],
                    ancient: ['First Dinosaur', 'Primordial Reptile', 'Dawn Beast', 'Origin Predator'],
                    extreme: ['Reality Dinosaur', 'Dimensional Rex', 'Void Raptor', 'Cosmic Predator'],
                    mythic: ['Universal Dinosaur', 'Infinite Beast', 'Creation\'s Predator', 'Eternal Rex'],
                    honorable: ['Sacred Dinosaur', 'Holy Ancient', 'Divine Beast', 'Blessed Rex'],
                    'master-class': ['Supreme Dinosaur', 'Perfect Predator', 'Ultimate Rex', 'Absolute Ancient'],
                    insane: ['Beyond Extinction', 'Impossible Dinosaur', 'The Unextinct', 'Pure Primordial'],
                    victorious: ['Never Extinct', 'Eternal Dinosaur', 'Undefeated Rex', 'Supreme Ancient']
                },
                'üê≤': {
                    common: ['Drake', 'Wyvern', 'Serpent', 'Wyrm'],
                    uncommon: ['Dragon', 'Fire Breath', 'Scaled One', 'Winged Beast'],
                    rare: ['Sky Dragon', 'Mountain Wyrm', 'Treasure Guardian', 'Storm Dragon'],
                    epic: ['Elder Dragon', 'Ancient Wyrm', 'Legendary Drake', 'Mythical Dragon'],
                    legendary: ['Shenlong', 'Tiamat', 'Bahamut', 'Dragon God'],
                    ancient: ['First Dragon', 'Primordial Wyrm', 'Dawn Serpent', 'Origin Drake'],
                    extreme: ['Reality Dragon', 'Dimensional Wyrm', 'Void Drake', 'Cosmic Serpent'],
                    mythic: ['Universal Dragon', 'Infinite Wyrm', 'Creation\'s Drake', 'Eternal Serpent'],
                    honorable: ['Sacred Dragon', 'Holy Wyrm', 'Divine Drake', 'Blessed Serpent'],
                    'master-class': ['Supreme Dragon', 'Perfect Wyrm', 'Ultimate Drake', 'Absolute Serpent'],
                    insane: ['Beyond Legend', 'Impossible Dragon', 'The Unimaginable', 'Pure Myth'],
                    victorious: ['Never Slain', 'Eternal Dragon', 'Undefeated Wyrm', 'Supreme Drake']
                },
                'üëë': {
                    common: ['Prince', 'Noble', 'Royal', 'Heir'],
                    uncommon: ['King', 'Emperor', 'Sovereign', 'Monarch'],
                    rare: ['High King', 'Grand Emperor', 'Supreme Ruler', 'Ultimate Sovereign'],
                    epic: ['King of Kings', 'Emperor of All', 'Ruler Supreme', 'Sovereign Absolute'],
                    legendary: ['God-King', 'Divine Emperor', 'Celestial Monarch', 'Eternal Ruler'],
                    ancient: ['First King', 'Primordial Ruler', 'Dawn Emperor', 'Origin Sovereign'],
                    extreme: ['Reality King', 'Dimensional Emperor', 'Void Monarch', 'Cosmic Sovereign'],
                    mythic: ['Universal King', 'Infinite Emperor', 'Creation\'s Ruler', 'Eternal Sovereign'],
                    honorable: ['Sacred King', 'Holy Emperor', 'Divine Monarch', 'Blessed Ruler'],
                    'master-class': ['Supreme King', 'Perfect Emperor', 'Ultimate Monarch', 'Absolute Sovereign'],
                    insane: ['Beyond Royalty', 'Impossible King', 'The Uncrowned', 'Pure Authority'],
                    victorious: ['Never Dethroned', 'Eternal King', 'Undefeated Emperor', 'Supreme Monarch']
                }
            },
            'Seasonal Pack': {
                'üéÉ': {
                    common: ['Jack', 'Pumpkin', 'Spooky', 'Halloween'],
                    uncommon: ['Jack-O', 'October King', 'Harvest Moon', 'Autumn Spirit'],
                    rare: ['Nightmare Lantern', 'Soul Keeper', 'Shadow Flame', 'Dark Harvest'],
                    epic: ['Eternal Halloween', 'Spirit King', 'Phantom Monarch', 'Samhain Lord'],
                    legendary: ['Ancient Samhain', 'Lord of Souls', 'Spectral Emperor', 'Death\'s Lantern'],
                    ancient: ['First Fear', 'Primordial Dark', 'Origin of Night', 'Dawn of Terror'],
                    extreme: ['Reality Haunter', 'Dimensional Fear', 'Void Horror', 'Cosmic Nightmare'],
                    mythic: ['Infinite Dread', 'Universal Terror', 'The Unseeable', 'Beyond Death'],
                    honorable: ['Sacred Spirit', 'Holy Guardian', 'Divine Protector', 'Blessed Soul'],
                    'master-class': ['Supreme Terror', 'Perfect Fear', 'Ultimate Phantom', 'Absolute Spirit'],
                    insane: ['Unfathomable Horror', 'The Impossible', 'Beyond Existence', 'Pure Chaos'],
                    victorious: ['Eternal Halloween', 'Never-Ending Night', 'Supreme Spirit', 'Ultimate Fear']
                },
                'üéÑ': {
                    common: ['Pine', 'Evergreen', 'Tree', 'Festive'],
                    uncommon: ['Holly', 'Noel', 'Yule Log', 'Winter Tree'],
                    rare: ['Frost Pine', 'Crystal Tree', 'Northern Star', 'Ice Evergreen'],
                    epic: ['Yggdrasil Junior', 'World Tree', 'Sacred Pine', 'Eternal Evergreen'],
                    legendary: ['Yggdrasil', 'Tree of Life', 'Cosmic Evergreen', 'Star Tree'],
                    ancient: ['First Tree', 'Primordial Pine', 'Dawn Evergreen', 'Origin Wood'],
                    extreme: ['Reality Tree', 'Dimensional Pine', 'Void Evergreen', 'Cosmic Branch'],
                    mythic: ['Universal Tree', 'Infinite Growth', 'Creation Pine', 'Eternal Life'],
                    honorable: ['Sacred Tree', 'Holy Pine', 'Divine Evergreen', 'Blessed Branch'],
                    'master-class': ['Supreme Tree', 'Perfect Pine', 'Ultimate Evergreen', 'Absolute Life'],
                    insane: ['Beyond Nature', 'Impossible Tree', 'The Unrooted', 'Pure Growth'],
                    victorious: ['Never Withers', 'Eternal Tree', 'Undefeated Pine', 'Supreme Evergreen']
                },
                'üå∏': {
                    common: ['Blossom', 'Sakura', 'Petal', 'Cherry'],
                    uncommon: ['Spring Bloom', 'Pink Petal', 'Hanami', 'Cherry Tree'],
                    rare: ['Eternal Bloom', 'Mystic Sakura', 'Spirit Blossom', 'Divine Petal'],
                    epic: ['Cherry Emperor', 'Bloom Sovereign', 'Sakura King', 'Petal Lord'],
                    legendary: ['Celestial Cherry', 'Cosmic Sakura', 'Star Blossom', 'Mythic Bloom'],
                    ancient: ['First Bloom', 'Primordial Petal', 'Dawn Cherry', 'Origin Sakura'],
                    extreme: ['Reality Bloom', 'Dimensional Petal', 'Void Sakura', 'Cosmic Cherry'],
                    mythic: ['Universal Bloom', 'Infinite Petal', 'Creation Sakura', 'Eternal Spring'],
                    honorable: ['Sacred Blossom', 'Holy Sakura', 'Divine Cherry', 'Blessed Bloom'],
                    'master-class': ['Supreme Blossom', 'Perfect Sakura', 'Ultimate Cherry', 'Absolute Bloom'],
                    insane: ['Beyond Beauty', 'Impossible Bloom', 'The Unblossomed', 'Pure Spring'],
                    victorious: ['Never Fades', 'Eternal Blossom', 'Undefeated Sakura', 'Supreme Bloom']
                },
                'üåô': {
                    common: ['Luna', 'Moon', 'Crescent', 'Night'],
                    uncommon: ['Moonbeam', 'Lunar', 'Eclipse', 'Tide Master'],
                    rare: ['Blood Moon', 'Super Moon', 'Dark Side', 'Lunar Eclipse'],
                    epic: ['Moon Emperor', 'Lunar Sovereign', 'Eclipse Lord', 'Tide King'],
                    legendary: ['Selene', 'Artemis Moon', 'Celestial Orb', 'Cosmic Tide'],
                    ancient: ['First Moon', 'Primordial Luna', 'Dawn Crescent', 'Origin Night'],
                    extreme: ['Reality Moon', 'Dimensional Luna', 'Void Crescent', 'Cosmic Eclipse'],
                    mythic: ['Universal Moon', 'Infinite Luna', 'Creation Tide', 'Eternal Night'],
                    honorable: ['Sacred Moon', 'Holy Luna', 'Divine Crescent', 'Blessed Night'],
                    'master-class': ['Supreme Moon', 'Perfect Luna', 'Ultimate Eclipse', 'Absolute Tide'],
                    insane: ['Beyond Orbit', 'Impossible Moon', 'The Unphased', 'Pure Gravity'],
                    victorious: ['Never Wanes', 'Eternal Moon', 'Undefeated Luna', 'Supreme Eclipse']
                },
                '‚≠ê': {
                    common: ['Star', 'Twinkle', 'Sparkle', 'Shine'],
                    uncommon: ['Nova', 'Stellar', 'Bright Star', 'Light Beam'],
                    rare: ['Supernova', 'Neutron Star', 'Pulsar', 'Red Giant'],
                    epic: ['Star Emperor', 'Stellar Sovereign', 'Nova King', 'Light Lord'],
                    legendary: ['Polaris', 'North Star', 'Celestial Star', 'Cosmic Light'],
                    ancient: ['First Star', 'Primordial Light', 'Dawn Shine', 'Origin Spark'],
                    extreme: ['Reality Star', 'Dimensional Light', 'Void Shine', 'Cosmic Nova'],
                    mythic: ['Universal Star', 'Infinite Light', 'Creation Spark', 'Eternal Shine'],
                    honorable: ['Sacred Star', 'Holy Light', 'Divine Shine', 'Blessed Spark'],
                    'master-class': ['Supreme Star', 'Perfect Light', 'Ultimate Nova', 'Absolute Shine'],
                    insane: ['Beyond Light', 'Impossible Star', 'The Unlit', 'Pure Energy'],
                    victorious: ['Never Dims', 'Eternal Star', 'Undefeated Light', 'Supreme Nova']
                },
                'üí´': {
                    common: ['Shooting Star', 'Meteor', 'Comet', 'Wish'],
                    uncommon: ['Falling Star', 'Cosmic Dust', 'Star Shower', 'Wish Granter'],
                    rare: ['Meteor Storm', 'Comet King', 'Wish Master', 'Star Rain'],
                    epic: ['Cosmic Emperor', 'Celestial Wish', 'Meteor Sovereign', 'Dream Lord'],
                    legendary: ['Halley\'s Heir', 'Cosmic Wish', 'Star Dream', 'Universal Hope'],
                    ancient: ['First Wish', 'Primordial Dream', 'Dawn Hope', 'Origin Star'],
                    extreme: ['Reality Wish', 'Dimensional Dream', 'Void Hope', 'Cosmic Desire'],
                    mythic: ['Universal Wish', 'Infinite Dream', 'Creation Hope', 'Eternal Desire'],
                    honorable: ['Sacred Wish', 'Holy Dream', 'Divine Hope', 'Blessed Star'],
                    'master-class': ['Supreme Wish', 'Perfect Dream', 'Ultimate Hope', 'Absolute Desire'],
                    insane: ['Beyond Dreams', 'Impossible Wish', 'The Unwished', 'Pure Hope'],
                    victorious: ['All Wishes Granted', 'Eternal Dream', 'Undefeated Hope', 'Supreme Wish']
                }
            },
            'House Pack': {},
            'Fire Monster Pack': {},
            'Ice Monster Pack': {},
            'Tropic Pack': {},
            'Seaside Pack': {},
            'Crazy Pack': {}
        };

        // Fill in default names if specific names aren't found
        function getDefaultName(icon, rarity) {
            const rarityPrefixes = {
                common: '', uncommon: 'Strong', rare: 'Mighty', epic: 'Epic', 
                legendary: 'Legendary', ancient: 'Ancient', extreme: 'Extreme',
                mythic: 'Mythic', honorable: 'Honorable', 'master-class': 'Master',
                insane: 'Insane', victorious: 'Victorious'
            };
            return `${rarityPrefixes[rarity]} ${icon}`;
        }

        function getCharacterName(packName, icon, rarity) {
            const names = characterNamesByIcon[packName]?.[icon]?.[rarity];
            if (names && names.length > 0) {
                return names[Math.floor(Math.random() * names.length)];
            }
            // Use default naming if specific names not found
            return getDefaultName(icon, rarity);
        }

        function revealCharacter(packName) {
            const pack = packs.find(p => p.name === packName);
            const rarity = getRarity();
            
            // Decrement Lucky Block uses if active
            if (gameState.luckyBlockUses > 0) {
                gameState.luckyBlockUses--;
                
                // Reset luck multiplier if no uses left
                if (gameState.luckyBlockUses === 0) {
                    gameState.luckMultiplier = 1;
                }
            }
            
            const icon = getCharacterIcon(pack, rarity); // Get appropriate icon based on rarity
            const rarityData = rarities.find(r => r.name === rarity);
            const characterName = getCharacterName(packName, icon, rarity); // Pass icon and rarity for creative names
            
            const characterPower = Math.floor(Math.random() * 50) + (rarities.indexOf(rarityData) * 20) + 10;
            
            const character = {
                id: Date.now(),
                name: characterName,
                icon: icon,
                rarity: rarity,
                level: 1,
                exp: 0,
                power: characterPower,
                health: characterPower,  // Health equals power
                packName: packName,  // Store pack name for type advantages
                wins: 0,
                battleStars: 0
            };
            
            gameState.characters.push(character);
            saveGameState(); // Save after getting new character
            
            const content = document.getElementById('modalContent');
            content.innerHTML = `
                <div class="revealed-character">
                    <h2>You got:</h2>
                    <div class="revealed-icon">${icon}</div>
                    <h3 style="color: ${rarityData.color};">${character.name}</h3>
                    <p style="font-size: 1.2em; margin: 10px 0; opacity: 0.8;">${rarity.toUpperCase()} ${icon}</p>
                    <p>Power: ‚ö° ${character.power}</p>
                    <p>Level: üî∞ ${character.level}</p>
                    <p>Pack: ${character.packName}</p>
                    <button class="battle-btn" onclick="closeModal()">Awesome!</button>
                </div>
            `;
            
            renderCharacters();
            updateStats();
        }

        function renderCharacters() {
            const grid = document.getElementById('characterGrid');
            if (!grid) return;
            
            let filtered = gameState.characters;
            
            if (gameState.currentFilter !== 'all') {
                if (gameState.currentFilter === 'mythic') {
                    filtered = gameState.characters.filter(c => 
                        ['mythic', 'honorable', 'master-class', 'insane', 'victorious'].includes(c.rarity)
                    );
                } else {
                    filtered = gameState.characters.filter(c => c.rarity === gameState.currentFilter);
                }
            }
            
            if (filtered.length === 0) {
                grid.innerHTML = '<p style="text-align: center; opacity: 0.6; grid-column: 1/-1;">No characters yet. Open some packs!</p>';
                return;
            }
            
            grid.innerHTML = filtered.map(char => {
                const expNeeded = char.level * 100;
                const expPercent = (char.exp / expNeeded) * 100;
                return `
                    <div class="character-card rarity-${char.rarity}" onclick="selectCharacter(${char.id})">
                        <div class="character-icon">${char.icon}</div>
                        <div class="character-name">${char.name}</div>
                        <div class="character-level">Lv.${char.level} ‚≠ê${char.battleStars}</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${expPercent}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function selectCharacter(id) {
            gameState.selectedCharacter = gameState.characters.find(c => c.id === id);
            const char = gameState.selectedCharacter;
            const rarityData = rarities.find(r => r.name === char.rarity);
            const expNeeded = char.level * 100;
            
            // Check for duplicates (same icon)
            const duplicates = gameState.characters.filter(c => c.icon === char.icon);
            const hasDuplicates = duplicates.length > 1;
            
            // Show applied trait
            let traitHTML = '';
            if (char.appliedTrait) {
                const traitItem = shopItems.find(si => si.id === char.appliedTrait);
                traitHTML = `<p><strong>Applied Trait:</strong> ${traitItem.icon} ${traitItem.name}</p>`;
            }
            
            // Show sell button if duplicates exist
            let sellButtonHTML = '';
            if (hasDuplicates) {
                sellButtonHTML = `
                    <button class="shop-buy-btn" id="sellCharBtn" style="margin-top: 10px; width: 100%; background: linear-gradient(135deg, #ff6b6b 0%, #ff4757 100%);">
                        üí∞ Sell for ${rarityData.sellPrice} Coins
                    </button>
                    <p style="font-size: 0.85em; opacity: 0.7; margin-top: 5px;">
                        You have ${duplicates.length} of this character
                    </p>
                `;
            }
            
            // Show trait application options if player has traits
            let traitButtonsHTML = '';
            if (gameState.ownedTraits.length > 0) {
                traitButtonsHTML = `
                    <hr style="margin: 15px 0; opacity: 0.3;">
                    <p style="font-size: 0.9em; opacity: 0.8; margin-bottom: 10px;">Apply Trait:</p>
                    <div id="traitButtonsContainer" style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center;">
                        ${gameState.ownedTraits.map((trait, index) => {
                            const traitItem = shopItems.find(si => si.id === trait.type);
                            return `
                                <button class="shop-buy-btn trait-apply-btn" data-trait-id="${trait.type}" data-char-id="${char.id}" style="padding: 8px 12px; font-size: 0.9em;">
                                    ${traitItem.icon} ${traitItem.name} (${trait.count})
                                </button>
                            `;
                        }).join('')}
                    </div>
                `;
            }
            
            document.getElementById('selectedCharacterStats').innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 4em; margin: 20px 0;">${char.icon}</div>
                    <h3 style="color: ${rarityData.color};">${char.name}</h3>
                    <hr style="margin: 15px 0; opacity: 0.3;">
                    <p><strong>Rarity:</strong> ${char.rarity.toUpperCase()}</p>
                    <p><strong>Level:</strong> ${char.level}</p>
                    <p><strong>Power:</strong> ‚ö° ${char.power}</p>
                    <p><strong>Wins:</strong> üèÜ ${char.wins}</p>
                    <p><strong>Battle Stars:</strong> ‚≠ê ${char.battleStars}</p>
                    <p><strong>Pack:</strong> ${char.packName || char.pack}</p>
                    ${traitHTML}
                    <hr style="margin: 15px 0; opacity: 0.3;">
                    <p style="font-size: 0.9em;"><strong>EXP:</strong> ${char.exp}/${expNeeded}</p>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${(char.exp/expNeeded)*100}%"></div>
                    </div>
                    ${traitButtonsHTML}
                    <button class="battle-btn" style="margin-top: 20px; width: 100%;" onclick="startBattle()">
                        ‚öîÔ∏è Battle
                    </button>
                    ${sellButtonHTML}
                </div>
            `;
            
            // Add event listeners after DOM update
            setTimeout(() => {
                // Sell button listener
                const sellBtn = document.getElementById('sellCharBtn');
                if (sellBtn) {
                    sellBtn.addEventListener('click', () => sellCharacter(char.id));
                }
                
                // Trait buttons listeners
                const traitBtns = document.querySelectorAll('.trait-apply-btn');
                traitBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const traitId = btn.getAttribute('data-trait-id');
                        const charId = parseInt(btn.getAttribute('data-char-id'));
                        applyTraitToCharacter(charId, traitId);
                    });
                });
            }, 0);
        }

        function sellCharacter(characterId) {
            const char = gameState.characters.find(c => c.id === characterId);
            if (!char) return;
            
            const rarityData = rarities.find(r => r.name === char.rarity);
            
            // Confirm sale
            if (!confirm(`Sell ${char.name} (${char.rarity}) for ${rarityData.sellPrice} coins?`)) {
                return;
            }
            
            // Remove character from collection
            gameState.characters = gameState.characters.filter(c => c.id !== characterId);
            
            // Add coins
            gameState.coins += rarityData.sellPrice;
            
            // Clear selected character if it was the one sold
            if (gameState.selectedCharacter?.id === characterId) {
                gameState.selectedCharacter = null;
                document.getElementById('selectedCharacterStats').innerHTML = `
                    <p style="opacity: 0.6; text-align: center; margin-top: 20px;">Select a character to view stats</p>
                `;
            }
            
            // Update display
            saveGameState();
            updateStats();
            renderCharacters();
            
            alert(`üí∞ Sold for ${rarityData.sellPrice} coins!`);
        }

        // Question banks for different modes
        const questionBanks = {
            math: {
                easy: [
                    { question: "2 + 3 = ?", answer: "5" },
                    { question: "5 √ó 2 = ?", answer: "10" },
                    { question: "10 - 4 = ?", answer: "6" },
                    { question: "6 √∑ 2 = ?", answer: "3" },
                    { question: "3 + 7 = ?", answer: "10" }
                ],
                medium: [
                    { question: "7 √ó 8 = ?", answer: "56" },
                    { question: "15 + 27 = ?", answer: "42" },
                    { question: "100 - 37 = ?", answer: "63" },
                    { question: "12 √ó 5 = ?", answer: "60" },
                    { question: "81 √∑ 9 = ?", answer: "9" },
                    { question: "25 + 36 = ?", answer: "61" },
                    { question: "144 √∑ 12 = ?", answer: "12" }
                ],
                hard: [
                    { question: "17 √ó 13 = ?", answer: "221" },
                    { question: "256 √∑ 16 = ?", answer: "16" },
                    { question: "125 + 89 = ?", answer: "214" },
                    { question: "23 √ó 11 = ?", answer: "253" },
                    { question: "1000 - 347 = ?", answer: "653" },
                    { question: "19 √ó 19 = ?", answer: "361" }
                ]
            },
            science: {
                easy: [
                    { question: "How many legs does a spider have?", answer: "8" },
                    { question: "What is H2O?", answer: "water" },
                    { question: "What do bees make?", answer: "honey" },
                    { question: "What gas do we breathe?", answer: "oxygen" },
                    { question: "What animal says meow?", answer: "cat" }
                ],
                medium: [
                    { question: "What planet is closest to the Sun?", answer: "mercury" },
                    { question: "What gas do plants absorb? (CO2 or O2)", answer: "co2" },
                    { question: "What force pulls objects down?", answer: "gravity" },
                    { question: "What is the largest planet?", answer: "jupiter" },
                    { question: "What is the hottest planet?", answer: "venus" },
                    { question: "What do caterpillars turn into?", answer: "butterfly" },
                    { question: "What is the center of an atom?", answer: "nucleus" }
                ],
                hard: [
                    { question: "What is the speed of light in m/s? (3√ó10^8, 3√ó10^7, 3√ó10^9)", answer: "3√ó10^8" },
                    { question: "What is the chemical symbol for gold?", answer: "au" },
                    { question: "How many chromosomes do humans have?", answer: "46" },
                    { question: "What is the powerhouse of the cell?", answer: "mitochondria" },
                    { question: "What is the freezing point of water in Celsius?", answer: "0" }
                ]
            },
            logic: {
                easy: [
                    { question: "What comes next: 2, 4, 6, 8, __?", answer: "10" },
                    { question: "If you have 3 apples and give away 1, how many left?", answer: "2" },
                    { question: "How many sides does a triangle have?", answer: "3" },
                    { question: "What number is between 5 and 7?", answer: "6" },
                    { question: "True or False: Fire is hot", answer: "true" }
                ],
                medium: [
                    { question: "What is the next letter: A, C, E, __?", answer: "g" },
                    { question: "True or False: A square has 4 equal sides", answer: "true" },
                    { question: "What comes next: 1, 1, 2, 3, 5, __?", answer: "8" },
                    { question: "If today is Monday, what is 3 days from now?", answer: "thursday" },
                    { question: "If A=1, B=2, C=3, what is D?", answer: "4" },
                    { question: "How many vowels in 'education'?", answer: "5" }
                ],
                hard: [
                    { question: "If all bloops are razzies and all razzies are lazzies, are all bloops lazzies? (yes/no)", answer: "yes" },
                    { question: "What comes next: 1, 4, 9, 16, __?", answer: "25" },
                    { question: "If 5 cats can catch 5 mice in 5 minutes, how many minutes for 100 cats to catch 100 mice?", answer: "5" },
                    { question: "What comes next in pattern: 2, 6, 12, 20, __?", answer: "30" },
                    { question: "If all Foos are Bars and some Bars are Bazs, are all Foos Bazs? (yes/no)", answer: "no" }
                ]
            }
        };

        let currentQuestion = null;
        let currentPowerIndex = null;

        function generateQuestion() {
            const mode = gameState.selectedGameMode;
            if (mode === 'fun') return null;
            
            const difficulty = gameState.questionDifficulty || 'medium';
            const bank = questionBanks[mode]?.[difficulty];
            if (!bank) return null;
            
            return bank[Math.floor(Math.random() * bank.length)];
        }

        function adjustDifficulty(correct) {
            if (correct) {
                // Make it harder
                if (gameState.questionDifficulty === 'easy') {
                    gameState.questionDifficulty = 'medium';
                } else if (gameState.questionDifficulty === 'medium') {
                    gameState.questionDifficulty = 'hard';
                }
            } else {
                // Make it easier
                if (gameState.questionDifficulty === 'hard') {
                    gameState.questionDifficulty = 'medium';
                } else if (gameState.questionDifficulty === 'medium') {
                    gameState.questionDifficulty = 'easy';
                }
            }
            saveGameState();
        }

        function showQuestion(powerIndex) {
            currentPowerIndex = powerIndex;
            currentQuestion = generateQuestion();
            
            if (!currentQuestion) {
                // Fun mode - no question needed
                executeUsePower(powerIndex);
                return;
            }
            
            const modal = document.getElementById('questionModal');
            const questionText = document.getElementById('questionText');
            const questionInput = document.getElementById('questionInput');
            const feedback = document.getElementById('questionFeedback');
            
            const modeNames = {
                math: 'üî¢ Math',
                science: 'üî¨ Science',
                logic: 'üß© Logic'
            };
            
            const difficultyIcons = {
                easy: 'üü¢',
                medium: 'üü°',
                hard: 'üî¥'
            };
            
            const difficultyText = `${difficultyIcons[gameState.questionDifficulty]} ${gameState.questionDifficulty.toUpperCase()}`;
            
            document.getElementById('questionTitle').textContent = `${modeNames[gameState.selectedGameMode]} Question - ${difficultyText}`;
            questionText.textContent = currentQuestion.question;
            questionInput.value = '';
            feedback.textContent = '';
            feedback.style.color = '';
            
            modal.classList.add('active');
            setTimeout(() => questionInput.focus(), 100);
        }

        function submitAnswer() {
            const input = document.getElementById('questionInput');
            const userAnswer = input.value.trim().toLowerCase();
            const feedback = document.getElementById('questionFeedback');
            
            if (!userAnswer) {
                feedback.textContent = '‚ö†Ô∏è Please enter an answer';
                feedback.style.color = '#ff6b6b';
                return;
            }
            
            const correctAnswer = currentQuestion.answer.toLowerCase();
            
            if (userAnswer === correctAnswer) {
                feedback.textContent = '‚úÖ Correct! Using power...';
                feedback.style.color = '#51cf66';
                
                // Increase difficulty on correct answer
                adjustDifficulty(true);
                
                setTimeout(() => {
                    document.getElementById('questionModal').classList.remove('active');
                    executeUsePower(currentPowerIndex);
                }, 1000);
            } else {
                feedback.textContent = '‚ùå Incorrect! Try again.';
                feedback.style.color = '#ff6b6b';
                
                // Decrease difficulty on wrong answer
                adjustDifficulty(false);
                
                input.value = '';
                input.focus();
            }
        }

        // Power types for each character
        // Pool of 15 different powers
        function generatePowers(character) {
            const basePower = character.power;
            
            const allPowers = [
                {
                    name: '‚öîÔ∏è Quick Strike',
                    description: 'Fast attack with moderate damage',
                    damage: Math.floor(basePower * 0.6),
                    cooldown: 0,
                    currentCooldown: 0,
                    warmup: 0
                },
                {
                    name: 'üí• Power Slam',
                    description: 'Heavy attack with high damage',
                    damage: Math.floor(basePower * 1.2),
                    cooldown: 2,
                    currentCooldown: 0,
                    warmup: 1
                },
                {
                    name: '‚ú® Special Ability',
                    description: 'Unique power with critical hit chance',
                    damage: Math.floor(basePower * 0.9),
                    cooldown: 1,
                    currentCooldown: 0,
                    critChance: 0.3,
                    warmup: 0
                },
                {
                    name: 'üî• Fire Blast',
                    description: 'Burning attack that deals extra damage',
                    damage: Math.floor(basePower * 1.1),
                    cooldown: 1,
                    currentCooldown: 0,
                    warmup: 1
                },
                {
                    name: '‚ùÑÔ∏è Ice Freeze',
                    description: 'Freezing attack with bonus damage',
                    damage: Math.floor(basePower * 1.0),
                    cooldown: 1,
                    currentCooldown: 0,
                    warmup: 0
                },
                {
                    name: '‚ö° Lightning Bolt',
                    description: 'Electric attack with high speed',
                    damage: Math.floor(basePower * 0.8),
                    cooldown: 0,
                    currentCooldown: 0,
                    warmup: 0
                },
                {
                    name: 'üå™Ô∏è Tornado Spin',
                    description: 'Whirlwind attack hitting multiple times',
                    damage: Math.floor(basePower * 0.7),
                    cooldown: 2,
                    currentCooldown: 0,
                    warmup: 0
                },
                {
                    name: 'üõ°Ô∏è Counter Strike',
                    description: 'Defensive move that counters with damage',
                    damage: Math.floor(basePower * 0.85),
                    cooldown: 2,
                    currentCooldown: 0,
                    warmup: 0
                },
                {
                    name: 'üí´ Star Beam',
                    description: 'Cosmic energy blast',
                    damage: Math.floor(basePower * 1.0),
                    cooldown: 1,
                    currentCooldown: 0,
                    critChance: 0.2,
                    warmup: 0
                },
                {
                    name: 'üåä Tidal Wave',
                    description: 'Massive water attack',
                    damage: Math.floor(basePower * 1.3),
                    cooldown: 3,
                    currentCooldown: 0,
                    warmup: 1
                },
                {
                    name: 'üó°Ô∏è Blade Fury',
                    description: 'Rapid slashing combo',
                    damage: Math.floor(basePower * 0.95),
                    cooldown: 1,
                    currentCooldown: 0,
                    warmup: 0
                },
                {
                    name: 'üíé Diamond Shield Bash',
                    description: 'Protected attack with guaranteed damage',
                    damage: Math.floor(basePower * 0.75),
                    cooldown: 1,
                    currentCooldown: 0,
                    warmup: 0
                },
                {
                    name: 'üåã Eruption',
                    description: 'Volcanic explosion dealing massive damage',
                    damage: Math.floor(basePower * 1.4),
                    cooldown: 3,
                    currentCooldown: 0,
                    warmup: 1
                },
                {
                    name: 'üëä Mega Punch',
                    description: 'Powerful physical strike',
                    damage: Math.floor(basePower * 1.15),
                    cooldown: 2,
                    currentCooldown: 0,
                    warmup: 1
                },
                {
                    name: 'üéØ Precision Shot',
                    description: 'Accurate attack that always hits hard',
                    damage: Math.floor(basePower * 1.05),
                    cooldown: 1,
                    currentCooldown: 0,
                    warmup: 0
                }
            ];
            
            // Randomly select 3 unique powers
            const shuffled = allPowers.sort(() => Math.random() - 0.5);
            const selectedPowers = shuffled.slice(0, 3);
            
            // Set initial warmup (can't use on first turn if warmup > 0)
            selectedPowers.forEach(power => {
                power.currentCooldown = power.warmup || 0;
            });
            
            return selectedPowers;
        }

        function getWorldClass(worldName) {
            return 'world-bg-' + worldName.toLowerCase().replace(/ /g, '-');
        }

        // Tournament System
        function startTournament(tournamentType = '32er') {
            if (!gameState.selectedCharacter) {
                alert('Select a character first!');
                return;
            }
            
            if (tournamentType === '32er') {
                start32erTournament();
            } else if (tournamentType === 'latrixhole') {
                startLatrixholeTournament();
            } else if (tournamentType === 'hopeone') {
                startHopeOneTournament();
            }
        }

        function start32erTournament() {
            // Generate 31 random opponents
            const opponents = [];
            for (let i = 0; i < 31; i++) {
                const opponentPack = packs[Math.floor(Math.random() * packs.length)];
                const opponentRarity = getRarity();
                const opponentIcon = getCharacterIcon(opponentPack, opponentRarity);
                const opponentRarityData = rarities.find(r => r.name === opponentRarity);
                const opponentName = getCharacterName(opponentPack.name, opponentIcon, opponentRarity);
                const opponentPower = Math.floor(Math.random() * 50) + (rarities.indexOf(opponentRarityData) * 20) + 10;
                
                opponents.push({
                    id: `tournament-${i}`,
                    name: opponentName,
                    icon: opponentIcon,
                    rarity: opponentRarity,
                    packName: opponentPack.name,
                    power: opponentPower,
                    health: opponentPower,
                    maxHealth: opponentPower
                });
            }

            // Create initial bracket - shuffle all 32 fighters
            const allFighters = [
                { 
                    ...gameState.selectedCharacter, 
                    isPlayer: true,
                    health: gameState.selectedCharacter.power,
                    maxHealth: gameState.selectedCharacter.power
                },
                ...opponents
            ];
            
            // Shuffle fighters for random bracket placement
            for (let i = allFighters.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allFighters[i], allFighters[j]] = [allFighters[j], allFighters[i]];
            }

            // Create bracket structure
            const bracket = {
                type: '32er',
                rounds: [
                    { name: 'Round of 32', matches: [] },
                    { name: 'Round of 16', matches: [] },
                    { name: 'Quarter Finals', matches: [] },
                    { name: 'Semi Finals', matches: [] },
                    { name: 'Finals', matches: [] }
                ],
                currentRound: 0,
                currentMatch: 0
            };

            // Initialize Round of 32 (16 matches)
            for (let i = 0; i < 16; i++) {
                bracket.rounds[0].matches.push({
                    fighter1: allFighters[i * 2],
                    fighter2: allFighters[i * 2 + 1],
                    winner: null
                });
            }

            gameState.currentTournament = bracket;
            showTournamentBracket();
        }

        function startLatrixholeTournament() {
            if (gameState.characters.length < 8) {
                alert('You need at least 8 characters for The Latrixhole!');
                return;
            }

            // Generate 255 random opponents (256 total with player)
            const opponents = [];
            for (let i = 0; i < 255; i++) {
                const opponentPack = packs[Math.floor(Math.random() * packs.length)];
                const opponentRarity = getRarity();
                const opponentIcon = getCharacterIcon(opponentPack, opponentRarity);
                const opponentRarityData = rarities.find(r => r.name === opponentRarity);
                const opponentName = getCharacterName(opponentPack.name, opponentIcon, opponentRarity);
                const opponentPower = Math.floor(Math.random() * 50) + (rarities.indexOf(opponentRarityData) * 20) + 10;
                
                opponents.push({
                    id: `latrix-${i}`,
                    name: opponentName,
                    icon: opponentIcon,
                    rarity: opponentRarity,
                    packName: opponentPack.name,
                    power: opponentPower,
                    health: opponentPower,
                    maxHealth: opponentPower
                });
            }

            // Shuffle all 256 fighters
            const allFighters = [
                { 
                    ...gameState.selectedCharacter, 
                    isPlayer: true,
                    health: gameState.selectedCharacter.power,
                    maxHealth: gameState.selectedCharacter.power
                },
                ...opponents
            ];
            
            for (let i = allFighters.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allFighters[i], allFighters[j]] = [allFighters[j], allFighters[i]];
            }

            // Create bracket structure - Playoffs then main bracket
            const bracket = {
                type: 'latrixhole',
                rounds: [
                    { name: 'Playoffs Round 1', matches: [], isPlayoff: true },  // 256‚Üí128
                    { name: 'Round of 128', matches: [] },  // 128‚Üí64
                    { name: 'Round of 64', matches: [] },   // 64‚Üí32
                    { name: 'Round of 32', matches: [] },   // 32‚Üí16
                    { name: 'Round of 16', matches: [] },   // 16‚Üí8
                    { name: 'Quarter Finals', matches: [] }, // 8‚Üí4
                    { name: 'Semi Finals', matches: [] },    // 4‚Üí2
                    { name: 'Finals', matches: [] }          // 2‚Üí1
                ],
                currentRound: 0,
                currentMatch: 0,
                usedCharacters: [], // Track which characters player has used
                availableCharacters: [...gameState.characters] // Clone for character rotation
            };

            // Initialize Playoffs (128 matches)
            for (let i = 0; i < 128; i++) {
                bracket.rounds[0].matches.push({
                    fighter1: allFighters[i * 2],
                    fighter2: allFighters[i * 2 + 1],
                    winner: null
                });
            }

            gameState.currentTournament = bracket;
            showTournamentBracket();
        }

        function startHopeOneTournament() {
            // Generate 15 random opponents (16 total with player)
            const opponents = [];
            for (let i = 0; i < 15; i++) {
                const opponentPack = packs[Math.floor(Math.random() * packs.length)];
                const opponentRarity = getRarity();
                const opponentIcon = getCharacterIcon(opponentPack, opponentRarity);
                const opponentRarityData = rarities.find(r => r.name === opponentRarity);
                const opponentName = getCharacterName(opponentPack.name, opponentIcon, opponentRarity);
                const opponentPower = Math.floor(Math.random() * 50) + (rarities.indexOf(opponentRarityData) * 20) + 10;
                
                opponents.push({
                    id: `hope-${i}`,
                    name: opponentName,
                    icon: opponentIcon,
                    rarity: opponentRarity,
                    packName: opponentPack.name,
                    power: opponentPower,
                    health: 1000,  // Everyone has 1000 HP!
                    maxHealth: 1000
                });
            }

            // Create initial bracket - shuffle all 16 fighters
            const allFighters = [
                { 
                    ...gameState.selectedCharacter, 
                    isPlayer: true,
                    health: 1000,  // Player also gets 1000 HP!
                    maxHealth: 1000
                },
                ...opponents
            ];
            
            // Shuffle fighters
            for (let i = allFighters.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allFighters[i], allFighters[j]] = [allFighters[j], allFighters[i]];
            }

            // Create bracket structure - Only 3 rounds
            const bracket = {
                type: 'hopeone',
                rounds: [
                    { name: 'Round of 16', matches: [] },  // 16‚Üí8
                    { name: 'Quarter Finals', matches: [] }, // 8‚Üí4
                    { name: 'Semi Finals', matches: [] },    // 4‚Üí2
                    { name: 'Finals', matches: [] }          // 2‚Üí1
                ],
                currentRound: 0,
                currentMatch: 0
            };

            // Initialize Round of 16 (8 matches)
            for (let i = 0; i < 8; i++) {
                bracket.rounds[0].matches.push({
                    fighter1: allFighters[i * 2],
                    fighter2: allFighters[i * 2 + 1],
                    winner: null
                });
            }

            gameState.currentTournament = bracket;
            showTournamentBracket();
        }

        function showTournamentBracket() {
            const tournament = gameState.currentTournament;
            
            // Safety checks
            if (!tournament || !tournament.rounds[tournament.currentRound]) {
                gameState.currentTournament = null;
                navigateTo('battle');
                return;
            }
            
            const currentRound = tournament.rounds[tournament.currentRound];
            
            // Check if current match exists
            if (tournament.currentMatch >= currentRound.matches.length) {
                return;
            }
            
            const currentMatch = currentRound.matches[tournament.currentMatch];
            
            if (!currentMatch) {
                return;
            }
            
            // Check if player is in this match
            const playerInMatch = currentMatch.fighter1?.isPlayer || currentMatch.fighter2?.isPlayer;
            
            if (playerInMatch) {
                // Player needs to fight this match
                startTournamentBattle();
            } else {
                // AI vs AI - simulate instantly
                simulateTournamentMatch();
            }
        }

        function renderTournamentBracket() {
            const tournament = gameState.currentTournament;
            if (!tournament) return '';

            let html = '<div class="tournament-bracket" style="display: flex; gap: 30px; overflow-x: auto; padding: 20px;">';
            
            tournament.rounds.forEach((round, roundIndex) => {
                if (round.matches.length === 0) return;
                
                html += `
                    <div class="bracket-round">
                        <div class="bracket-round-title">${round.name}</div>
                `;
                
                round.matches.forEach((match, matchIndex) => {
                    const isCurrent = roundIndex === tournament.currentRound && matchIndex === tournament.currentMatch;
                    
                    html += `
                        <div class="bracket-match ${isCurrent ? 'current' : ''}">
                            <div class="bracket-fighter ${match.winner === match.fighter1 ? 'winner' : match.winner ? 'loser' : ''}">
                                <span style="font-size: 1.5em;">${match.fighter1.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold;">${match.fighter1.name}</div>
                                    <div style="font-size: 0.9em; opacity: 0.8;">‚ö° ${match.fighter1.power}</div>
                                </div>
                            </div>
                            <div class="bracket-fighter ${match.winner === match.fighter2 ? 'winner' : match.winner ? 'loser' : ''}">
                                <span style="font-size: 1.5em;">${match.fighter2.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold;">${match.fighter2.name}</div>
                                    <div style="font-size: 0.9em; opacity: 0.8;">‚ö° ${match.fighter2.power}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            
            html += '</div>';
            return html;
        }

        function startTournamentBattle() {
            const tournament = gameState.currentTournament;
            const match = tournament.rounds[tournament.currentRound].matches[tournament.currentMatch];
            
            // Determine which fighter is the player and which is opponent
            let player, opponent;
            if (match.fighter1.isPlayer) {
                player = match.fighter1;
                opponent = match.fighter2;
            } else {
                player = match.fighter2;
                opponent = match.fighter1;
            }

            // Generate powers for both fighters
            player.powers = generatePowers(player);
            opponent.powers = generatePowers(opponent);
            
            // Randomly decide who goes first
            const playerGoesFirst = Math.random() < 0.5;
            
            // Set up battle state
            gameState.currentBattle = {
                player: { ...player, currentHealth: player.maxHealth || 100 },
                opponent: { ...opponent, currentHealth: opponent.maxHealth || 100 },
                turn: playerGoesFirst ? 'player' : 'opponent',
                round: 1,
                log: [],
                isTournament: true
            };
            
            // Show battle screen
            document.getElementById('battleScreen').classList.add('active');
            
            // Set world background
            const worldClass = getWorldClass(gameState.currentWorld);
            const battleBg = document.getElementById('battleBackground');
            battleBg.className = worldClass;
            
            // Update UI
            const roundName = tournament.rounds[tournament.currentRound].name;
            document.getElementById('battleWorldName').textContent = `üèÜ Tournament - ${roundName}`;
            updateBattleUI();
            
            // If opponent goes first, announce it and start their turn
            if (!playerGoesFirst) {
                addBattleLog(`${opponent.name} goes first!`, 'normal');
                setTimeout(() => {
                    opponentTurn();
                }, 1500);
            } else {
                addBattleLog(`${player.name} goes first!`, 'normal');
            }
        }

        function simulateTournamentMatch() {
            const tournament = gameState.currentTournament;
            
            // Safety checks
            if (!tournament || !tournament.rounds[tournament.currentRound]) {
                return;
            }
            
            const match = tournament.rounds[tournament.currentRound].matches[tournament.currentMatch];
            
            if (!match || !match.fighter1 || !match.fighter2) {
                return;
            }
            
            // Simple simulation based on power
            const fighter1Power = match.fighter1.power + Math.random() * 50;
            const fighter2Power = match.fighter2.power + Math.random() * 50;
            
            match.winner = fighter1Power > fighter2Power ? match.fighter1 : match.fighter2;
            
            // Move to next match
            advanceTournament();
        }

        function advanceTournament() {
            const tournament = gameState.currentTournament;
            
            tournament.currentMatch++;
            
            // Check if round is complete
            if (tournament.currentMatch >= tournament.rounds[tournament.currentRound].matches.length) {
                // Check if all matches in this round have winners
                const currentRoundMatches = tournament.rounds[tournament.currentRound].matches;
                const allMatchesComplete = currentRoundMatches.every(match => match && match.winner !== null);
                
                if (!allMatchesComplete) {
                    return;
                }
                
                // Round complete - advance to next round
                tournament.currentMatch = 0;
                tournament.currentRound++;
                
                // Check if tournament is complete
                if (tournament.currentRound >= tournament.rounds.length) {
                    endTournament();
                    return;
                }
                
                // Set up next round matches
                const prevRound = tournament.rounds[tournament.currentRound - 1];
                const nextRound = tournament.rounds[tournament.currentRound];
                
                // Clear any existing matches in the next round
                nextRound.matches = [];
                
                for (let i = 0; i < prevRound.matches.length; i += 2) {
                    const match1 = prevRound.matches[i];
                    const match2 = prevRound.matches[i + 1];
                    
                    // Safety check - make sure both matches have winners
                    if (match1 && match1.winner && match2 && match2.winner) {
                        let fighter1 = match1.winner;
                        let fighter2 = match2.winner;
                        
                        // For Latrixhole, update player fighter with new character
                        if (tournament.type === 'latrixhole') {
                            if (fighter1.isPlayer) {
                                fighter1 = {
                                    ...gameState.selectedCharacter,
                                    isPlayer: true,
                                    health: gameState.selectedCharacter.power,
                                    maxHealth: gameState.selectedCharacter.power
                                };
                            }
                            if (fighter2.isPlayer) {
                                fighter2 = {
                                    ...gameState.selectedCharacter,
                                    isPlayer: true,
                                    health: gameState.selectedCharacter.power,
                                    maxHealth: gameState.selectedCharacter.power
                                };
                            }
                        }
                        
                        nextRound.matches.push({
                            fighter1: fighter1,
                            fighter2: fighter2,
                            winner: null
                        });
                    }
                }
            }
            
            // Continue tournament
            showTournamentBracket();
        }

        function endTournament() {
            const tournament = gameState.currentTournament;
            
            const finalsRound = tournament.rounds[tournament.rounds.length - 1];
            
            if (!finalsRound || !finalsRound.matches || finalsRound.matches.length === 0) {
                gameState.currentTournament = null;
                navigateTo('battle');
                return;
            }
            
            const finalMatch = finalsRound.matches[0];
            
            // Safety check
            if (!finalMatch || !finalMatch.winner) {
                gameState.currentTournament = null;
                navigateTo('battle');
                return;
            }
            
            const champion = finalMatch.winner;
            
            if (champion.isPlayer) {
                // Player won the tournament!
                let coinsEarned, starsEarned, winsEarned, expEarned, title, description;
                
                if (tournament.type === 'latrixhole') {
                    coinsEarned = 25000;
                    starsEarned = 500;
                    winsEarned = 8;
                    expEarned = 2000;
                    title = 'üåÄ LATRIXHOLE CHAMPION!';
                    description = 'You conquered 256 fighters and mastered character rotation!';
                } else if (tournament.type === 'hopeone') {
                    coinsEarned = 10000;
                    starsEarned = 200;
                    winsEarned = 4;
                    expEarned = 800;
                    title = 'üíé HOPE ONE CHAMPION!';
                    description = 'You proved your skill in the ultimate equalizer tournament!';
                } else { // 32er
                    coinsEarned = 5000;
                    starsEarned = 100;
                    winsEarned = 5;
                    expEarned = 500;
                    title = 'üèÜ TOURNAMENT CHAMPION!';
                    description = 'You defeated all 31 opponents and claimed victory!';
                }
                
                gameState.coins += coinsEarned;
                gameState.battleStars += starsEarned;
                
                const char = gameState.characters.find(c => c.id === gameState.selectedCharacter.id);
                if (char) {
                    char.wins += winsEarned;
                    char.battleStars += starsEarned;
                    char.exp += expEarned;
                }
                
                showTournamentResults(true, coinsEarned, starsEarned, expEarned, title, description, tournament.type);
            } else {
                // Player lost somewhere in the tournament
                showTournamentResults(false, 0, 0, 0, '', '', tournament.type);
            }
            
            gameState.currentTournament = null;
            saveGameState();
        }

        function showTournamentResults(won, coins, stars, exp, title, description, tournamentType) {
            const resultsPage = document.createElement('div');
            resultsPage.id = 'tournamentResultsPage';
            resultsPage.className = 'battle-screen active';
            
            if (won) {
                resultsPage.innerHTML = `
                    <div class="battle-results-container">
                        <div class="battle-result">
                            <div class="result-icon">${tournamentType === 'latrixhole' ? 'üåÄ' : tournamentType === 'hopeone' ? 'üíé' : 'üèÜ'}</div>
                            <div class="result-title" style="color: #ffd700;">${title}</div>
                            <div style="font-size: 1.3em; margin: 20px 0;">
                                ${description}
                            </div>
                            <div class="result-rewards">
                                <h3>Championship Rewards:</h3>
                                <div style="font-size: 1.5em; margin: 10px 0;">${tournamentType === 'latrixhole' ? 'üåÄ Latrixhole Winner' : tournamentType === 'hopeone' ? 'üíé Hope Champion' : 'üèÜ Tournament Winner'}</div>
                                <div style="font-size: 1.3em; margin: 10px 0;">‚≠ê ${stars} Battle Stars</div>
                                <div style="font-size: 1.3em; margin: 10px 0;">üí∞ ${coins} Coins</div>
                                <div style="font-size: 1.3em; margin: 10px 0;">üìà ${exp} EXP</div>
                            </div>
                            <button class="continue-btn" onclick="exitTournamentResults()">Return to Battle Menu</button>
                        </div>
                    </div>
                `;
            } else {
                resultsPage.innerHTML = `
                    <div class="battle-results-container">
                        <div class="battle-result">
                            <div class="result-icon">ü•à</div>
                            <div class="result-title" style="color: #ff6b6b;">ELIMINATED</div>
                            <div style="font-size: 1.2em; margin: 20px 0;">
                                You were eliminated from the tournament.
                            </div>
                            <div class="result-rewards">
                                Better luck next time!<br>
                                Train harder and try again.
                            </div>
                            <button class="continue-btn" onclick="exitTournamentResults()">Return to Battle Menu</button>
                        </div>
                    </div>
                `;
            }
            
            document.body.appendChild(resultsPage);
        }

        function exitTournamentResults() {
            const resultsPage = document.getElementById('tournamentResultsPage');
            if (resultsPage) {
                resultsPage.remove();
            }
            navigateTo('battle');
        }

        function startBattle() {
            if (!gameState.selectedCharacter) {
                alert('Select a character first!');
                return;
            }
            
            // Generate opponent
            const opponentPack = packs[Math.floor(Math.random() * packs.length)];
            const opponentRarity = getRarity();
            const opponentIcon = getCharacterIcon(opponentPack, opponentRarity); // Get icon based on rarity
            const opponentRarityData = rarities.find(r => r.name === opponentRarity);
            const opponentName = getCharacterName(opponentPack.name, opponentIcon, opponentRarity);
            const opponentPower = Math.floor(Math.random() * 50) + (rarities.indexOf(opponentRarityData) * 20) + 10;
            
            const opponent = {
                name: opponentName,
                icon: opponentIcon,
                rarity: opponentRarity,
                packName: opponentPack.name,  // Add pack name for type advantages
                power: opponentPower,
                health: opponentPower,  // Health equals power
                maxHealth: opponentPower,  // Max health equals power
                currentHealth: opponentPower  // Current health equals power
            };
            
            const player = {
                ...gameState.selectedCharacter,
                maxHealth: gameState.selectedCharacter.power,  // Max health equals power
                currentHealth: gameState.selectedCharacter.power  // Current health equals power
            };
            
            // Generate powers for both fighters
            player.powers = generatePowers(player);
            opponent.powers = generatePowers(opponent);
            
            // Randomly decide who goes first
            const playerGoesFirst = Math.random() < 0.5;
            
            // Set up battle state
            gameState.currentBattle = {
                player: player,
                opponent: opponent,
                turn: playerGoesFirst ? 'player' : 'opponent',
                round: 1,
                log: []
            };
            
            // Show battle screen
            document.getElementById('battleScreen').classList.add('active');
            
            // Set world background
            const worldClass = getWorldClass(gameState.currentWorld);
            const battleBg = document.getElementById('battleBackground');
            battleBg.className = worldClass;
            
            // Update UI
            document.getElementById('battleWorldName').textContent = gameState.currentWorld;
            updateBattleUI();
            
            // If opponent goes first, announce it and start their turn
            if (!playerGoesFirst) {
                addBattleLog(`${opponent.name} goes first!`, 'normal');
                setTimeout(() => {
                    opponentTurn();
                }, 1500);
            } else {
                addBattleLog(`${player.name} goes first!`, 'normal');
            }
        }

        function updateBattleUI() {
            const battle = gameState.currentBattle;
            const player = battle.player;
            const opponent = battle.opponent;
            
            // Player info
            document.getElementById('playerBattleIcon').textContent = player.icon;
            document.getElementById('playerBattleName').textContent = player.name;
            document.getElementById('playerBattlePower').textContent = player.power;
            document.getElementById('playerBattleLevel').textContent = player.level;
            updateHealthBar('player', player.currentHealth, player.maxHealth);
            
            // Opponent info
            document.getElementById('opponentBattleIcon').textContent = opponent.icon;
            document.getElementById('opponentBattleName').textContent = opponent.name;
            document.getElementById('opponentBattlePower').textContent = opponent.power;
            document.getElementById('opponentBattleRarity').textContent = opponent.rarity.toUpperCase();
            updateHealthBar('opponent', opponent.currentHealth, opponent.maxHealth);
            
            // Render player powers
            renderPowerButtons();
            
            // Update turn indicator
            const turnText = battle.turn === 'player' ? 'üéÆ Your Turn!' : 'ü§ñ Opponent\'s Turn...';
            document.getElementById('turnIndicator').textContent = turnText;
        }

        function renderPowerButtons() {
            const battle = gameState.currentBattle;
            const powersDiv = document.getElementById('playerPowers');
            
            powersDiv.innerHTML = battle.player.powers.map((power, index) => {
                const isDisabled = power.currentCooldown > 0 || battle.turn !== 'player';
                let statusText = '';
                
                if (power.currentCooldown > 0) {
                    // Check if this is warmup (first turn) or cooldown
                    if (battle.round === 1 && power.warmup > 0) {
                        statusText = `<div class="power-cooldown">‚è±Ô∏è Warmup: ${power.currentCooldown} turn${power.currentCooldown > 1 ? 's' : ''}</div>`;
                    } else {
                        statusText = `<div class="power-cooldown">‚è≥ Cooldown: ${power.currentCooldown} turn${power.currentCooldown > 1 ? 's' : ''}</div>`;
                    }
                }
                
                return `
                    <button class="power-btn" 
                            onclick="usePower(${index})"
                            ${isDisabled ? 'disabled' : ''}>
                        <div class="power-name">${power.name}</div>
                        <div class="power-desc">${power.description}</div>
                        <div class="power-damage">üí• Damage: ~${power.damage}</div>
                        ${statusText}
                    </button>
                `;
            }).join('');
        }

        function updateHealthBar(fighter, current, max) {
            const percent = Math.max(0, (current / max) * 100);
            const hpText = `${Math.max(0, Math.floor(current))}/${max}`;
            
            if (fighter === 'player') {
                document.getElementById('playerBattleHP').textContent = hpText;
                document.getElementById('playerBattleHealthFill').style.width = percent + '%';
                document.getElementById('playerHealthPercent').textContent = Math.floor(percent) + '%';
            } else {
                document.getElementById('opponentBattleHP').textContent = hpText;
                document.getElementById('opponentBattleHealthFill').style.width = percent + '%';
                document.getElementById('opponentHealthPercent').textContent = Math.floor(percent) + '%';
            }
        }

        function addBattleLog(message, type = 'normal') {
            const log = document.getElementById('battleActionLog');
            const entry = document.createElement('div');
            entry.className = `action-entry ${type}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function usePower(powerIndex) {
            // Check if question is required based on game mode
            if (gameState.selectedGameMode !== 'fun') {
                showQuestion(powerIndex);
            } else {
                executeUsePower(powerIndex);
            }
        }

        // Type advantage system
        function getTypeAdvantage(attackerPackName, defenderPackName, attackerCharacter = null) {
            const attackerPack = packs.find(p => p.name === attackerPackName);
            const defenderPack = packs.find(p => p.name === defenderPackName);
            
            if (!attackerPack || !defenderPack) return 1.0;
            
            // Check pack-based advantage
            if (attackerPack.strengths && attackerPack.strengths.includes(defenderPackName)) {
                return 1.5; // 50% bonus damage
            }
            
            // Check bonus strengths from traits
            if (attackerCharacter && attackerCharacter.bonusStrengths && 
                attackerCharacter.bonusStrengths.includes(defenderPackName)) {
                return 1.5; // 50% bonus damage from trait
            }
            
            // Check if attacker has disadvantage
            if (attackerPack.weaknesses && attackerPack.weaknesses.includes(defenderPackName)) {
                return 0.75; // 25% reduced damage
            }
            
            return 1.0; // Neutral matchup
        }

        function executeUsePower(powerIndex) {
            const battle = gameState.currentBattle;
            if (battle.turn !== 'player') return;
            
            const power = battle.player.powers[powerIndex];
            
            // Calculate damage with variance
            let damage = power.damage + Math.floor(Math.random() * 10) - 5;
            let isCrit = false;
            
            // Apply type advantage
            const typeMultiplier = getTypeAdvantage(battle.player.packName, battle.opponent.packName, battle.player);
            damage = Math.floor(damage * typeMultiplier);
            
            // Check for critical hit
            if (power.critChance && Math.random() < power.critChance) {
                damage = Math.floor(damage * 1.5);
                isCrit = true;
            }
            
            // Determine effectiveness message
            let effectMsg = '';
            if (typeMultiplier > 1.0) {
                effectMsg = ' ‚ö° Super effective!';
            } else if (typeMultiplier < 1.0) {
                effectMsg = ' üõ°Ô∏è Not very effective...';
            }
            
            // Trigger attack animation
            const playerIcon = document.getElementById('playerBattleIcon');
            const opponentIcon = document.getElementById('opponentBattleIcon');
            
            if (isCrit) {
                playerIcon.classList.add('critical-attacking');
            } else {
                playerIcon.classList.add('attacking');
            }
            
            // Log action
            const logMsg = `${battle.player.name} used ${power.name} - ${damage} damage!${isCrit ? ' üí´ CRITICAL HIT!' : ''}${effectMsg}`;
            addBattleLog(logMsg, isCrit ? 'critical' : 'damage');
            
            // After attack animation, show damage on opponent
            setTimeout(() => {
                // Remove attack animation
                playerIcon.classList.remove('attacking', 'critical-attacking');
                
                // Apply damage
                battle.opponent.currentHealth -= damage;
                
                // Trigger damage animation on opponent
                opponentIcon.classList.add('taking-damage');
                
                // Update UI
                updateBattleUI();
                
                // Remove damage animation
                setTimeout(() => {
                    opponentIcon.classList.remove('taking-damage');
                }, 600);
                
            }, isCrit ? 1000 : 800);
            
            // Set cooldown
            power.currentCooldown = power.cooldown;
            
            // Check if opponent defeated
            setTimeout(() => {
                if (battle.opponent.currentHealth <= 0) {
                    setTimeout(() => endBattle(true), 1000);
                    return;
                }
                
                // Switch turn
                battle.turn = 'opponent';
                updateBattleUI();
                
                // Opponent's turn after delay
                setTimeout(opponentTurn, 1500);
            }, isCrit ? 2000 : 1500);
        }

        function opponentTurn() {
            const battle = gameState.currentBattle;
            
            // AI chooses a power (prefers off-cooldown, higher damage)
            const availablePowers = battle.opponent.powers.filter(p => p.currentCooldown === 0);
            if (availablePowers.length === 0) return; // Shouldn't happen
            
            const chosenPower = availablePowers.sort((a, b) => b.damage - a.damage)[0];
            const powerIndex = battle.opponent.powers.indexOf(chosenPower);
            
            // Calculate damage
            let damage = chosenPower.damage + Math.floor(Math.random() * 10) - 5;
            let isCrit = false;
            
            // Apply type advantage
            const typeMultiplier = getTypeAdvantage(battle.opponent.packName, battle.player.packName, battle.opponent);
            damage = Math.floor(damage * typeMultiplier);
            
            if (chosenPower.critChance && Math.random() < chosenPower.critChance) {
                damage = Math.floor(damage * 1.5);
                isCrit = true;
            }
            
            // Determine effectiveness message
            let effectMsg = '';
            if (typeMultiplier > 1.0) {
                effectMsg = ' ‚ö° Super effective!';
            } else if (typeMultiplier < 1.0) {
                effectMsg = ' üõ°Ô∏è Not very effective...';
            }
            
            // Trigger attack animation
            const playerIcon = document.getElementById('playerBattleIcon');
            const opponentIcon = document.getElementById('opponentBattleIcon');
            
            if (isCrit) {
                opponentIcon.classList.add('critical-attacking');
            } else {
                opponentIcon.classList.add('attacking');
            }
            
            // Log action
            const logMsg = `${battle.opponent.name} used ${chosenPower.name} - ${damage} damage!${isCrit ? ' üí´ CRITICAL HIT!' : ''}${effectMsg}`;
            addBattleLog(logMsg, isCrit ? 'critical' : 'damage');
            
            // After attack animation, show damage on player
            setTimeout(() => {
                // Remove attack animation
                opponentIcon.classList.remove('attacking', 'critical-attacking');
                
                // Apply damage
                battle.player.currentHealth -= damage;
                
                // Trigger damage animation on player
                playerIcon.classList.add('taking-damage');
                
                // Set cooldown
                chosenPower.currentCooldown = chosenPower.cooldown;
                
                // Reduce all cooldowns
                battle.player.powers.forEach(p => p.currentCooldown = Math.max(0, p.currentCooldown - 1));
                battle.opponent.powers.forEach(p => p.currentCooldown = Math.max(0, p.currentCooldown - 1));
                
                // Update UI
                updateBattleUI();
                
                // Remove damage animation
                setTimeout(() => {
                    playerIcon.classList.remove('taking-damage');
                }, 600);
                
            }, isCrit ? 1000 : 800);
            
            // Check if player defeated and switch turn
            setTimeout(() => {
                if (battle.player.currentHealth <= 0) {
                    setTimeout(() => endBattle(false), 1000);
                    return;
                }
                
                // Switch turn back to player
                battle.turn = 'player';
                battle.round++;
                updateBattleUI();
            }, isCrit ? 2000 : 1500);
        }

        function endBattle(playerWon) {
            const battle = gameState.currentBattle;
            
            // Check if this is a tournament battle
            if (battle.isTournament) {
                handleTournamentBattleEnd(playerWon);
                return;
            }
            
            // Automatically hide battle screen and show results
            document.getElementById('battleScreen').classList.remove('active');
            
            // Create and show results page
            const resultsPage = document.createElement('div');
            resultsPage.id = 'battleResultsPage';
            resultsPage.className = 'battle-screen active';
            
            if (playerWon) {
                // Calculate rewards
                const opponentRarityIndex = rarities.findIndex(r => r.name === battle.opponent.rarity);
                const starsEarned = Math.max(1, Math.floor(opponentRarityIndex / 2) + 1);
                const coinsEarned = Math.floor(Math.random() * 50) + 20 + (opponentRarityIndex * 10);
                const expEarned = Math.floor(Math.random() * 30) + 20 + (opponentRarityIndex * 5);
                
                gameState.wins++;
                gameState.coins += coinsEarned;
                
                const char = gameState.characters.find(c => c.id === gameState.selectedCharacter.id);
                char.wins++;
                char.battleStars += starsEarned;
                char.exp += expEarned;
                
                let levelUpMsg = '';
                const expNeeded = char.level * 100;
                if (char.exp >= expNeeded) {
                    char.level++;
                    char.exp -= expNeeded;
                    const powerGain = Math.floor(Math.random() * 10) + 5;
                    char.power += powerGain;
                    char.health = char.power;  // Update health to match new power
                    levelUpMsg = `<div style="color: #ffd700; font-size: 1.5em; margin: 15px 0;">üéâ LEVEL UP! Now Level ${char.level}!</div>`;
                }
                
                resultsPage.innerHTML = `
                    <div class="battle-results-container">
                        <div class="battle-result">
                            <div class="result-icon">üèÜ</div>
                            <div class="result-title" style="color: #51cf66;">VICTORY!</div>
                            <div style="font-size: 1.2em; margin: 20px 0;">
                                You defeated <strong>${battle.opponent.name}</strong>!
                            </div>
                            <div class="result-rewards">
                                <h3>Rewards Earned:</h3>
                                <div style="font-size: 1.3em; margin: 10px 0;">‚≠ê ${starsEarned} Battle Stars</div>
                                <div style="font-size: 1.3em; margin: 10px 0;">üí∞ ${coinsEarned} Coins</div>
                                <div style="font-size: 1.3em; margin: 10px 0;">üìà ${expEarned} EXP</div>
                            </div>
                            ${levelUpMsg}
                            <button class="continue-btn" onclick="exitBattleResults()">Continue</button>
                        </div>
                    </div>
                `;
                
                checkWorldUnlocks();
                updateStats();
                saveGameState();
            } else {
                resultsPage.innerHTML = `
                    <div class="battle-results-container">
                        <div class="battle-result">
                            <div class="result-icon">üíÄ</div>
                            <div class="result-title" style="color: #ff6b6b;">DEFEAT</div>
                            <div style="font-size: 1.2em; margin: 20px 0;">
                                <strong>${battle.opponent.name}</strong> was too powerful!
                            </div>
                            <div class="result-rewards">
                                Better luck next time!<br>
                                Keep training and try again.
                            </div>
                            <button class="continue-btn" onclick="exitBattleResults()">Try Again</button>
                        </div>
                    </div>
                `;
            }
            
            document.body.appendChild(resultsPage);
        }

        function handleTournamentBattleEnd(playerWon) {
            const tournament = gameState.currentTournament;
            
            // Safety checks
            if (!tournament || !tournament.rounds[tournament.currentRound]) {
                document.getElementById('battleScreen').classList.remove('active');
                navigateTo('battle');
                return;
            }
            
            const match = tournament.rounds[tournament.currentRound].matches[tournament.currentMatch];
            
            if (!match) {
                document.getElementById('battleScreen').classList.remove('active');
                navigateTo('battle');
                return;
            }
            
            // Hide battle screen
            document.getElementById('battleScreen').classList.remove('active');
            
            if (playerWon) {
                // Player won this match - set them as winner
                if (match.fighter1 && match.fighter1.isPlayer) {
                    match.winner = match.fighter1;
                } else if (match.fighter2 && match.fighter2.isPlayer) {
                    match.winner = match.fighter2;
                }
                
                // Show quick victory message and advance
                const resultsPage = document.createElement('div');
                resultsPage.id = 'tournamentMatchResultsPage';
                resultsPage.className = 'battle-screen active';
                
                const roundName = tournament.rounds[tournament.currentRound].name;
                const matchesLeft = tournament.rounds[tournament.currentRound].matches.length - tournament.currentMatch - 1;
                
                resultsPage.innerHTML = `
                    <div class="battle-results-container">
                        <div class="battle-result">
                            <div class="result-icon">‚úÖ</div>
                            <div class="result-title" style="color: #51cf66;">MATCH WON!</div>
                            <div style="font-size: 1.2em; margin: 20px 0;">
                                You advanced in the <strong>${roundName}</strong>!
                            </div>
                            ${renderTournamentBracket()}
                            <button class="continue-btn" onclick="continueToNextTournamentMatch()">
                                ${tournament.currentMatch < tournament.rounds[tournament.currentRound].matches.length - 1 ? 
                                  'Continue Tournament' : 'Advance to Next Round'}
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(resultsPage);
            } else {
                // Player lost - they're eliminated
                if (match.fighter1 && match.fighter1.isPlayer) {
                    match.winner = match.fighter2;
                } else if (match.fighter2 && match.fighter2.isPlayer) {
                    match.winner = match.fighter1;
                }
                
                endTournament();
            }
        }

        function continueToNextTournamentMatch() {
            const resultsPage = document.getElementById('tournamentMatchResultsPage');
            if (resultsPage) {
                resultsPage.remove();
            }
            
            const tournament = gameState.currentTournament;
            
            // Check if this is Latrixhole and if we're about to advance to next round
            if (tournament.type === 'latrixhole') {
                const isLastMatchOfRound = tournament.currentMatch >= tournament.rounds[tournament.currentRound].matches.length - 1;
                
                if (isLastMatchOfRound) {
                    // Mark current character as used
                    tournament.usedCharacters.push(gameState.selectedCharacter.id);
                    
                    // Check if advancing to new round (not just next match)
                    if (tournament.currentRound < tournament.rounds.length - 1) {
                        // Show character selection for next round
                        showLatrixholeCharacterSelection();
                        return;
                    }
                }
            }
            
            advanceTournament();
        }

        function showLatrixholeCharacterSelection() {
            const tournament = gameState.currentTournament;
            const availableChars = gameState.characters.filter(c => !tournament.usedCharacters.includes(c.id));
            
            if (availableChars.length === 0) {
                alert('No more characters available! Tournament ended.');
                endTournament();
                return;
            }
            
            const selectionPage = document.createElement('div');
            selectionPage.id = 'latrixCharSelectionPage';
            selectionPage.className = 'battle-screen active';
            
            selectionPage.innerHTML = `
                <div class="battle-results-container">
                    <div class="battle-result">
                        <div class="result-icon">üåÄ</div>
                        <div class="result-title" style="color: #8a2be2;">SELECT NEW CHARACTER</div>
                        <div style="font-size: 1.2em; margin: 20px 0;">
                            Choose a DIFFERENT character for the next round!
                        </div>
                        <p style="opacity: 0.8; margin-bottom: 20px;">Characters used: ${tournament.usedCharacters.length}</p>
                        
                        <div class="character-grid" style="grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); max-width: 800px; margin: 20px auto;">
                            ${availableChars.map(char => {
                                const rarityData = rarities.find(r => r.name === char.rarity);
                                return `
                                    <div class="character-card" 
                                         onclick="selectLatrixholeCharacter(${char.id})"
                                         style="border-color: ${rarityData.color}; cursor: pointer;">
                                        <div class="character-icon">${char.icon}</div>
                                        <div class="character-name">${char.name}</div>
                                        <div class="character-rarity" style="color: ${rarityData.color};">
                                            ${char.rarity.toUpperCase()}
                                        </div>
                                        <div class="character-level">Level ${char.level}</div>
                                        <div class="character-power">‚ö° ${char.power}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(selectionPage);
        }

        function selectLatrixholeCharacter(characterId) {
            const char = gameState.characters.find(c => c.id === characterId);
            if (!char) return;
            
            // Update selected character
            gameState.selectedCharacter = char;
            
            // Remove selection page
            const selectionPage = document.getElementById('latrixCharSelectionPage');
            if (selectionPage) {
                selectionPage.remove();
            }
            
            // Continue tournament with new character
            advanceTournament();
        }

        function exitBattleResults() {
            const resultsPage = document.getElementById('battleResultsPage');
            if (resultsPage) {
                resultsPage.remove();
            }
            renderCharacters();
            updateStats();
        }

        function exitBattle() {
            document.getElementById('battleScreen').classList.remove('active');
            document.getElementById('battleResultScreen').style.display = 'none';
            document.getElementById('battleResultScreen').innerHTML = '';
            document.getElementById('turnIndicator').style.display = 'block';
            document.getElementById('battleActionLog').innerHTML = '';
            renderCharacters();
            if (gameState.selectedCharacter) {
                selectCharacter(gameState.selectedCharacter.id);
            }
        }

        function checkWorldUnlocks() {
            worlds.forEach(world => {
                if (!world.unlocked && gameState.wins >= world.requirement) {
                    world.unlocked = true;
                    gameState.unlockedWorlds.push(world.name);
                    saveGameState(); // Save after unlocking world
                    alert(`üåç New World Unlocked: ${world.name}!`);
                }
            });
            renderWorlds();
        }

        function renderBattleSelection() {
            const battleContent = document.getElementById('battleContent');
            if (!battleContent) return;
            
            if (gameState.characters.length === 0) {
                battleContent.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px;">
                        <div style="font-size: 5em; margin-bottom: 20px;">üì¶</div>
                        <h2>No Characters Yet!</h2>
                        <p style="font-size: 1.2em; opacity: 0.8; margin: 20px 0;">Open some packs to get characters first!</p>
                        <button class="battle-btn" onclick="navigateTo('packs')" style="padding: 15px 40px; font-size: 1.2em;">
                            Go to Packs
                        </button>
                    </div>
                `;
                return;
            }
            
            battleContent.innerHTML = `
                <div style="max-width: 1000px; margin: 0 auto;">
                    <h2 style="text-align: center; margin-bottom: 30px;">Choose Battle Mode</h2>
                    
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px; margin-bottom: 40px;">
                        <div class="battle-mode-card" onclick="showNormalBattle()">
                            <div style="font-size: 4em; margin-bottom: 15px;">‚öîÔ∏è</div>
                            <h3>Quick Battle</h3>
                            <p>Fight a single opponent and earn rewards</p>
                        </div>
                        
                        <div class="battle-mode-card" onclick="showTournamentSelection()">
                            <div style="font-size: 4em; margin-bottom: 15px;">üèÜ</div>
                            <h3>Tournaments</h3>
                            <p>Choose from 3 tournament types with massive rewards!</p>
                        </div>
                    </div>
                    
                    <div id="battleModeContent"></div>
                </div>
            `;
        }

        function showNormalBattle() {
            const content = document.getElementById('battleModeContent');
            content.innerHTML = `
                <h2 style="text-align: center; margin: 30px 0 20px;">Select Your Fighter</h2>
                <div class="character-grid" style="grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));">
                    ${gameState.characters.map(char => {
                        const rarityData = rarities.find(r => r.name === char.rarity);
                        const isSelected = gameState.selectedCharacter?.id === char.id;
                        return `
                            <div class="character-card ${isSelected ? 'selected' : ''}" 
                                 onclick="selectCharacterForBattle(${char.id})"
                                 style="border-color: ${rarityData.color}; ${isSelected ? 'box-shadow: 0 0 20px ' + rarityData.color + ';' : ''}">
                                <div class="character-icon">${char.icon}</div>
                                <div class="character-name">${char.name}</div>
                                <div class="character-rarity" style="color: ${rarityData.color};">
                                    ${char.rarity.toUpperCase()}
                                </div>
                                <div class="character-level">Level ${char.level}</div>
                                <div class="character-power">‚ö° ${char.power}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                ${gameState.selectedCharacter ? `
                    <div style="text-align: center; margin-top: 40px;">
                        <button class="battle-btn" onclick="startBattle()" style="font-size: 1.5em; padding: 20px 60px;">
                            ‚öîÔ∏è Start Battle!
                        </button>
                    </div>
                ` : `
                    <div style="text-align: center; margin-top: 40px; opacity: 0.6;">
                        <p style="font-size: 1.2em;">Select a character to begin</p>
                    </div>
                `}
            `;
        }

        function showTournamentSelection() {
            const content = document.getElementById('battleModeContent');
            
            const charCount = gameState.characters.length;
            const canDo32er = charCount >= 1;
            const canDoLatrixhole = charCount >= 8; // Need 8 different characters
            const canDoHopeOne = charCount >= 1;
            
            content.innerHTML = `
                <h2 style="text-align: center; margin: 30px 0 20px;">üèÜ Choose Tournament Type</h2>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px; margin-top: 30px;">
                    <div class="battle-mode-card ${!canDo32er ? 'locked' : ''}" onclick="${canDo32er ? 'showTournamentBattle(\'32er\')' : ''}">
                        <div style="font-size: 3em; margin-bottom: 10px;">ü•ä</div>
                        <h3>The 32er</h3>
                        <p style="font-size: 0.95em; margin: 10px 0;">32 fighters, single elimination</p>
                        <p style="font-size: 0.85em; opacity: 0.8;">5 rounds of intense battles</p>
                        <div style="margin-top: 15px; padding: 10px; background: rgba(255,215,0,0.2); border-radius: 8px;">
                            <strong>Rewards:</strong><br>
                            üèÜ Tournament Champion<br>
                            ‚≠ê 100 Battle Stars<br>
                            üí∞ 5,000 Coins
                        </div>
                        ${!canDo32er ? '<p style="color: #ff6b6b; margin-top: 10px;">Need 1+ characters</p>' : ''}
                    </div>
                    
                    <div class="battle-mode-card ${!canDoLatrixhole ? 'locked' : ''}" onclick="${canDoLatrixhole ? 'showTournamentBattle(\'latrixhole\')' : ''}">
                        <div style="font-size: 3em; margin-bottom: 10px;">üåÄ</div>
                        <h3>The Latrixhole</h3>
                        <p style="font-size: 0.95em; margin: 10px 0;">256 fighters ‚Üí 128 qualify</p>
                        <p style="font-size: 0.85em; opacity: 0.8;">Must use different character each round!</p>
                        <div style="margin-top: 15px; padding: 10px; background: rgba(138,43,226,0.2); border-radius: 8px;">
                            <strong>Rewards:</strong><br>
                            üåÄ Latrixhole Champion<br>
                            ‚≠ê 500 Battle Stars<br>
                            üí∞ 25,000 Coins
                        </div>
                        ${!canDoLatrixhole ? '<p style="color: #ff6b6b; margin-top: 10px;">Need 8+ characters</p>' : ''}
                    </div>
                    
                    <div class="battle-mode-card ${!canDoHopeOne ? 'locked' : ''}" onclick="${canDoHopeOne ? 'showTournamentBattle(\'hopeone\')' : ''}">
                        <div style="font-size: 3em; margin-bottom: 10px;">üíé</div>
                        <h3>The Hope One</h3>
                        <p style="font-size: 0.95em; margin: 10px 0;">16 fighters, all 1000 HP</p>
                        <p style="font-size: 0.85em; opacity: 0.8;">3 rounds, pure skill tournament</p>
                        <div style="margin-top: 15px; padding: 10px; background: rgba(0,191,255,0.2); border-radius: 8px;">
                            <strong>Rewards:</strong><br>
                            üíé Hope Champion<br>
                            ‚≠ê 200 Battle Stars<br>
                            üí∞ 10,000 Coins
                        </div>
                        ${!canDoHopeOne ? '<p style="color: #ff6b6b; margin-top: 10px;">Need 1+ characters</p>' : ''}
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button class="battle-btn" onclick="renderBattleSelection()" style="background: rgba(255,255,255,0.2);">
                        ‚Üê Back to Battle Modes
                    </button>
                </div>
            `;
        }

        function showTournamentBattle(tournamentType = '32er') {
            const content = document.getElementById('battleModeContent');
            
            let description = '';
            let requirement = '';
            
            if (tournamentType === '32er') {
                description = 'Choose wisely! You\'ll face 31 opponents in a single-elimination tournament.';
                requirement = '';
            } else if (tournamentType === 'latrixhole') {
                description = 'Epic challenge! Start with 256 fighters, only 128 qualify. You must use a DIFFERENT character each round!';
                requirement = gameState.characters.length < 8 ? 
                    '<p style="color: #ff6b6b; text-align: center; margin-bottom: 20px;">‚ö†Ô∏è You need at least 8 characters for The Latrixhole!</p>' : '';
            } else if (tournamentType === 'hopeone') {
                description = 'The equalizer! All fighters get exactly 1000 HP. Pure skill tournament with just 3 rounds.';
                requirement = '';
            }
            
            content.innerHTML = `
                <h2 style="text-align: center; margin: 30px 0 20px;">Select Your Fighter</h2>
                <p style="text-align: center; font-size: 1.1em; opacity: 0.8; margin-bottom: 20px;">
                    ${description}
                </p>
                ${requirement}
                <div class="character-grid" style="grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));">
                    ${gameState.characters.map(char => {
                        const rarityData = rarities.find(r => r.name === char.rarity);
                        const isSelected = gameState.selectedCharacter?.id === char.id;
                        return `
                            <div class="character-card ${isSelected ? 'selected' : ''}" 
                                 onclick="selectCharacterForBattle(${char.id})"
                                 style="border-color: ${rarityData.color}; ${isSelected ? 'box-shadow: 0 0 20px ' + rarityData.color + ';' : ''}">
                                <div class="character-icon">${char.icon}</div>
                                <div class="character-name">${char.name}</div>
                                <div class="character-rarity" style="color: ${rarityData.color};">
                                    ${char.rarity.toUpperCase()}
                                </div>
                                <div class="character-level">Level ${char.level}</div>
                                <div class="character-power">‚ö° ${char.power}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                ${gameState.selectedCharacter && (tournamentType !== 'latrixhole' || gameState.characters.length >= 8) ? `
                    <div style="text-align: center; margin-top: 40px;">
                        <button class="battle-btn" onclick="startTournament('${tournamentType}')" style="font-size: 1.5em; padding: 20px 60px; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);">
                            üèÜ Enter Tournament!
                        </button>
                    </div>
                ` : `
                    <div style="text-align: center; margin-top: 40px; opacity: 0.6;">
                        <p style="font-size: 1.2em;">Select a character to enter the tournament</p>
                    </div>
                `}
            `;
        }

        function selectCharacterForBattle(characterId) {
            const char = gameState.characters.find(c => c.id === characterId);
            if (char) {
                gameState.selectedCharacter = char;
                renderBattleSelection();
            }
        }

        function renderWorlds() {
            const grid = document.getElementById('worldGrid');
            if (!grid) return;
            
            grid.innerHTML = worlds.map(world => `
                <div class="world-card ${world.unlocked ? '' : 'locked'}">
                    <div onclick="selectWorld('${world.name}', ${world.unlocked})" style="cursor: pointer;">
                        <div class="world-name">${world.unlocked ? 'üåç' : 'üîí'} ${world.name}</div>
                        <div class="world-requirement">
                            ${world.unlocked ? 'Unlocked!' : `Requires ${world.requirement} wins`}
                        </div>
                    </div>
                    ${world.unlocked ? `
                        <button class="battle-btn" onclick="event.stopPropagation(); exploreWorld('${world.name}')" style="margin-top: 15px; padding: 12px 20px; font-size: 1em; width: 100%;">
                            üó∫Ô∏è Explore Further
                        </button>
                    ` : ''}
                </div>
            `).join('');
        }

        function selectWorld(name, unlocked) {
            if (!unlocked) {
                alert('This world is locked! Win more battles to unlock it.');
                return;
            }
            gameState.currentWorld = name;
            alert(`Now battling in: ${name}`);
        }

        function exploreWorld(worldName) {
            // Initialize world exploration data if needed
            if (!gameState.worldExplorations[worldName]) {
                gameState.worldExplorations[worldName] = {
                    food: 100,
                    wood: 50,
                    stone: 30,
                    rescuedCharacters: [],
                    homes: [],
                    lastVisit: Date.now()
                };
            }
            
            gameState.currentExploringWorld = worldName;
            
            // Hide all pages and show exploration page
            document.querySelectorAll('.page-content').forEach(p => p.style.display = 'none');
            const explorationPage = document.getElementById('explorationPage');
            explorationPage.style.display = 'block';
            
            // Apply world-specific background
            const worldClass = getWorldClass(worldName);
            explorationPage.className = 'page-content ' + worldClass;
            explorationPage.style.backgroundSize = 'cover';
            explorationPage.style.backgroundPosition = 'center';
            explorationPage.style.minHeight = '100vh';
            
            renderExploration();
        }

        function renderExploration() {
            const worldName = gameState.currentExploringWorld;
            const worldData = gameState.worldExplorations[worldName];
            
            // World-themed emojis
            const worldThemes = {
                'Starter Plains': { icon: 'üåæ', color: '#90EE90' },
                'Desert Oasis': { icon: 'üèúÔ∏è', color: '#FFD700' },
                'Frozen Tundra': { icon: '‚ùÑÔ∏è', color: '#87CEEB' },
                'Mystic Forest': { icon: 'üå≤', color: '#228B22' },
                'Volcano Peak': { icon: 'üåã', color: '#FF4500' },
                'Ocean Depths': { icon: 'üåä', color: '#4169E1' },
                'Sky Castle': { icon: '‚òÅÔ∏è', color: '#B0E0E6' },
                'Shadow Realm': { icon: 'üåë', color: '#4B0082' },
                'Crystal Dimension': { icon: 'üíé', color: '#FF1493' },
                'Ultimate Arena': { icon: '‚ö°', color: '#FFD700' }
            };
            
            const theme = worldThemes[worldName] || { icon: 'üåç', color: '#90EE90' };
            
            document.getElementById('explorationWorldTitle').innerHTML = `${theme.icon} ${worldName} Exploration`;
            
            const content = document.getElementById('explorationContent');
            content.innerHTML = `
                <div style="max-width: 1200px; margin: 0 auto; padding: 20px;">
                    <!-- Welcome Banner -->
                    <div style="background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4)); border: 3px solid ${theme.color}; border-radius: 20px; padding: 30px; margin-bottom: 30px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
                        <div style="font-size: 5em; margin-bottom: 15px;">${theme.icon}</div>
                        <h2 style="color: ${theme.color}; font-size: 2em; margin-bottom: 10px;">Welcome to ${worldName}</h2>
                        <p style="opacity: 0.9; font-size: 1.1em;">Rescue stranded characters, gather resources, build homes, and create a thriving community!</p>
                    </div>

                    <!-- Resources Panel -->
                    <div style="background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(0,0,0,0.5)); border: 2px solid rgba(255,255,255,0.3); border-radius: 15px; padding: 25px; margin-bottom: 30px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);">
                        <h3 style="text-align: center; margin-bottom: 20px; font-size: 1.8em;">üì¶ Resources</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; text-align: center;">
                            <div style="background: rgba(255,165,0,0.2); border: 2px solid rgba(255,165,0,0.5); border-radius: 10px; padding: 20px;">
                                <div style="font-size: 3em;">üçñ</div>
                                <div style="font-size: 1.5em; font-weight: bold; color: #FFA500;">${worldData.food}</div>
                                <div style="opacity: 0.9; margin-top: 5px;">Food</div>
                            </div>
                            <div style="background: rgba(139,69,19,0.2); border: 2px solid rgba(139,69,19,0.5); border-radius: 10px; padding: 20px;">
                                <div style="font-size: 3em;">ü™µ</div>
                                <div style="font-size: 1.5em; font-weight: bold; color: #8B4513;">${worldData.wood}</div>
                                <div style="opacity: 0.9; margin-top: 5px;">Wood</div>
                            </div>
                            <div style="background: rgba(128,128,128,0.2); border: 2px solid rgba(128,128,128,0.5); border-radius: 10px; padding: 20px;">
                                <div style="font-size: 3em;">ü™®</div>
                                <div style="font-size: 1.5em; font-weight: bold; color: #808080;">${worldData.stone}</div>
                                <div style="opacity: 0.9; margin-top: 5px;">Stone</div>
                            </div>
                        </div>
                    </div>

                    <!-- Actions Grid -->
                    <h3 style="text-align: center; margin-bottom: 20px; font-size: 1.8em;">üéÆ Actions</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 25px; margin-bottom: 30px;">
                        <div class="battle-mode-card" onclick="attemptRescue()" style="background: linear-gradient(135deg, rgba(255,0,0,0.3), rgba(255,0,0,0.1));">
                            <div style="font-size: 3.5em; margin-bottom: 10px;">üÜò</div>
                            <h3>Rescue Mission</h3>
                            <p>Search for stranded characters</p>
                            <p style="font-size: 0.9em; color: #FFA500; margin-top: 10px; font-weight: bold;">Cost: 10 üçñ Food</p>
                            <p style="font-size: 0.85em; opacity: 0.8; margin-top: 5px;">70% success rate</p>
                        </div>
                        
                        <div class="battle-mode-card" onclick="gatherResources()" style="background: linear-gradient(135deg, rgba(0,255,0,0.3), rgba(0,255,0,0.1));">
                            <div style="font-size: 3.5em; margin-bottom: 10px;">‚õèÔ∏è</div>
                            <h3>Gather Resources</h3>
                            <p>Collect food, wood, and stone</p>
                            <p style="font-size: 0.9em; color: #90EE90; margin-top: 10px; font-weight: bold;">Free action</p>
                            <p style="font-size: 0.85em; opacity: 0.8; margin-top: 5px;">15-35 üçñ, 10-25 ü™µ, 5-15 ü™®</p>
                        </div>
                        
                        <div class="battle-mode-card" onclick="buildHome()" style="background: linear-gradient(135deg, rgba(0,0,255,0.3), rgba(0,0,255,0.1));">
                            <div style="font-size: 3.5em; margin-bottom: 10px;">üè†</div>
                            <h3>Build Home</h3>
                            <p>Construct shelter for characters</p>
                            <p style="font-size: 0.9em; color: #87CEEB; margin-top: 10px; font-weight: bold;">Cost: 30 ü™µ, 20 ü™®</p>
                            <p style="font-size: 0.85em; opacity: 0.8; margin-top: 5px;">Houses up to 5 characters</p>
                        </div>
                        
                        <div class="battle-mode-card" onclick="feedCharacters()" style="background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,215,0,0.1));">
                            <div style="font-size: 3.5em; margin-bottom: 10px;">üçΩÔ∏è</div>
                            <h3>Feed Characters</h3>
                            <p>Keep rescued characters happy</p>
                            <p style="font-size: 0.9em; color: #FFD700; margin-top: 10px; font-weight: bold;">Cost: ${worldData.rescuedCharacters.length * 2} üçñ Food</p>
                            <p style="font-size: 0.85em; opacity: 0.8; margin-top: 5px;">+20 happiness per character</p>
                        </div>
                    </div>

                    <!-- Rescued Characters -->
                    <div style="background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(0,0,0,0.5)); border: 2px solid rgba(255,255,255,0.3); border-radius: 15px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);">
                        <h3 style="text-align: center; margin-bottom: 20px; font-size: 1.8em;">üë• Rescued Characters (${worldData.rescuedCharacters.length})</h3>
                        ${worldData.rescuedCharacters.length === 0 ? 
                            '<p style="text-align: center; opacity: 0.6; font-size: 1.2em; padding: 40px 0;">No rescued characters yet. Go on a rescue mission!</p>' :
                            `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 20px;">
                                ${worldData.rescuedCharacters.map(char => `
                                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.3); border-radius: 12px; padding: 20px; text-align: center; transition: all 0.3s;" onmouseover="this.style.transform='translateY(-5px)'; this.style.borderColor='rgba(255,215,0,0.8)'" onmouseout="this.style.transform=''; this.style.borderColor='rgba(255,255,255,0.3)'">
                                        <div style="font-size: 3.5em; margin-bottom: 10px;">${char.icon}</div>
                                        <div style="font-size: 1em; font-weight: bold; margin-bottom: 5px;">${char.name}</div>
                                        <div style="font-size: 0.9em; padding: 5px 10px; background: rgba(0,0,0,0.3); border-radius: 15px; display: inline-block;">
                                            ${char.happiness >= 80 ? 'üòä Happy' : char.happiness >= 50 ? 'üòê Okay' : 'üòî Sad'}
                                        </div>
                                        <div style="margin-top: 8px; background: rgba(0,0,0,0.3); border-radius: 10px; height: 8px; overflow: hidden;">
                                            <div style="width: ${char.happiness}%; height: 100%; background: ${char.happiness >= 80 ? '#4CAF50' : char.happiness >= 50 ? '#FFA500' : '#F44336'}; transition: width 0.3s;"></div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>`
                        }
                    </div>

                    <!-- Homes -->
                    <div style="background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(0,0,0,0.5)); border: 2px solid rgba(255,255,255,0.3); border-radius: 15px; padding: 25px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);">
                        <h3 style="text-align: center; margin-bottom: 20px; font-size: 1.8em;">üèòÔ∏è Homes Built (${worldData.homes.length})</h3>
                        ${worldData.homes.length === 0 ?
                            '<p style="text-align: center; opacity: 0.6; font-size: 1.2em; padding: 40px 0;">No homes built yet. Build homes to house more characters!</p>' :
                            `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 20px;">
                                ${worldData.homes.map((home, idx) => `
                                    <div style="background: linear-gradient(135deg, rgba(139,69,19,0.3), rgba(139,69,19,0.1)); border: 2px solid rgba(139,69,19,0.5); border-radius: 12px; padding: 20px; text-align: center; transition: all 0.3s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform=''">
                                        <div style="font-size: 3em; margin-bottom: 10px;">üè†</div>
                                        <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">Home ${idx + 1}</div>
                                        <div style="font-size: 0.9em; opacity: 0.9;">
                                            Capacity: ${home.residents || 0}/5
                                        </div>
                                        <div style="margin-top: 8px; background: rgba(0,0,0,0.3); border-radius: 10px; height: 8px; overflow: hidden;">
                                            <div style="width: ${(home.residents || 0) / 5 * 100}%; height: 100%; background: #4CAF50; transition: width 0.3s;"></div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>`
                        }
                    </div>
                </div>
            `;
        }

        function attemptRescue() {
            const worldName = gameState.currentExploringWorld;
            const worldData = gameState.worldExplorations[worldName];
            
            if (worldData.food < 10) {
                alert('‚ùå Not enough food! You need 10 food for a rescue mission.');
                return;
            }
            
            // Deduct food
            worldData.food -= 10;
            
            // Random chance to find a character
            if (Math.random() < 0.7) { // 70% success rate
                const pack = packs[Math.floor(Math.random() * packs.length)];
                const rarity = getRarity();
                const icon = getCharacterIcon(pack, rarity);
                const name = getCharacterName(pack.name, icon, rarity);
                
                const rescuedChar = {
                    icon: icon,
                    name: name,
                    happiness: 100,
                    lastFed: Date.now()
                };
                
                worldData.rescuedCharacters.push(rescuedChar);
                
                saveGameState();
                renderExploration();
                
                alert(`üéâ Rescue successful! You found ${name}!`);
            } else {
                saveGameState();
                renderExploration();
                alert('üòî No characters found this time. Keep trying!');
            }
        }

        function gatherResources() {
            const worldName = gameState.currentExploringWorld;
            const worldData = gameState.worldExplorations[worldName];
            
            const foodGained = Math.floor(Math.random() * 20) + 15; // 15-35 food
            const woodGained = Math.floor(Math.random() * 15) + 10; // 10-25 wood
            const stoneGained = Math.floor(Math.random() * 10) + 5;  // 5-15 stone
            
            worldData.food += foodGained;
            worldData.wood += woodGained;
            worldData.stone += stoneGained;
            
            saveGameState();
            renderExploration();
            
            alert(`‚õèÔ∏è Resources gathered!\n+${foodGained} Food\n+${woodGained} Wood\n+${stoneGained} Stone`);
        }

        function buildHome() {
            const worldName = gameState.currentExploringWorld;
            const worldData = gameState.worldExplorations[worldName];
            
            if (worldData.wood < 30) {
                alert('‚ùå Not enough wood! You need 30 wood.');
                return;
            }
            
            if (worldData.stone < 20) {
                alert('‚ùå Not enough stone! You need 20 stone.');
                return;
            }
            
            // Deduct resources
            worldData.wood -= 30;
            worldData.stone -= 20;
            
            // Build home
            worldData.homes.push({
                capacity: 5,
                residents: 0
            });
            
            saveGameState();
            renderExploration();
            
            alert(`üè† Home built successfully! You can now house more characters.`);
        }

        function feedCharacters() {
            const worldName = gameState.currentExploringWorld;
            const worldData = gameState.worldExplorations[worldName];
            
            if (worldData.rescuedCharacters.length === 0) {
                alert('‚ùå No characters to feed!');
                return;
            }
            
            const foodNeeded = worldData.rescuedCharacters.length * 2;
            
            if (worldData.food < foodNeeded) {
                alert(`‚ùå Not enough food! You need ${foodNeeded} food to feed all characters.`);
                return;
            }
            
            // Deduct food
            worldData.food -= foodNeeded;
            
            // Increase happiness
            worldData.rescuedCharacters.forEach(char => {
                char.happiness = Math.min(100, char.happiness + 20);
                char.lastFed = Date.now();
            });
            
            saveGameState();
            renderExploration();
            
            alert(`üçΩÔ∏è All characters fed! Everyone is happier now!`);
        }

        function navigateTo(pageName) {
            // Hide all pages
            document.querySelectorAll('.page-content').forEach(p => p.style.display = 'none');
            
            // Show selected page
            const pageMap = {
                'home': 'homePage',
                'packs': 'packsPage',
                'shop': 'shopPage',
                'collection': 'collectionPage',
                'battle': 'battlePage',
                'worlds': 'worldsPage'
            };
            
            const pageId = pageMap[pageName];
            if (pageId) {
                document.getElementById(pageId).style.display = 'block';
            }
            
            // Refresh content when navigating to specific pages
            if (pageName === 'collection') {
                renderCharacters();
            } else if (pageName === 'battle') {
                renderBattleSelection();
            } else if (pageName === 'worlds') {
                renderWorlds();
            } else if (pageName === 'shop') {
                renderShop();
            }
        }

        function switchTab(tabName) {
            // Legacy function - redirect to navigateTo
            navigateTo(tabName);
        }

        function filterByRarity(rarity) {
            gameState.currentFilter = rarity;
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            
            // Find and activate the clicked button
            document.querySelectorAll('.filter-btn').forEach(btn => {
                if (btn.getAttribute('data-filter') === rarity) {
                    btn.classList.add('active');
                }
            });
            
            renderCharacters();
        }

        function setMode(mode) {
            gameState.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            
            // Find and activate the correct mode button
            if (mode === 'online') {
                document.querySelector('.mode-btn.online').classList.add('active');
                alert('üåê Online Mode: Battle against other players! (Simulated for demo)');
            } else {
                document.querySelector('.mode-btn.offline').classList.add('active');
                alert('üè† Offline Mode: Battle against AI opponents!');
            }
        }

        function closeModal() {
            document.getElementById('packModal').classList.remove('active');
        }

        function updateStats() {
            const coinsEl = document.getElementById('coins');
            const totalCharsEl = document.getElementById('totalCharacters');
            const winsEl = document.getElementById('winsCount');
            const worldsEl = document.getElementById('worldsUnlocked');
            
            if (coinsEl) coinsEl.textContent = gameState.coins;
            if (totalCharsEl) totalCharsEl.textContent = gameState.characters.length;
            if (winsEl) winsEl.textContent = gameState.wins;
            if (worldsEl) worldsEl.textContent = gameState.unlockedWorlds.length;
        }

        // Don't initialize on page load - wait for login

        // Global error handler to prevent error displays
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            // Suppress all error displays
            return true;
        };

        window.addEventListener('unhandledrejection', function(event) {
            // Suppress unhandled promise rejections
            event.preventDefault();
        });
    </script>
</body>
</html>
